<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AIRBOT Play Controller: arm::Robot&lt; DOF &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AIRBOT Play Controller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>arm</b></li><li class="navelem"><a class="el" href="classarm_1_1Robot.html">Robot</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classarm_1_1Robot-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">arm::Robot&lt; DOF &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classarm_1_1Robot.html" title="The Robot class for controlling the robot arm.">Robot</a> class for controlling the robot arm.  
 <a href="classarm_1_1Robot.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="command__base_8hpp_source.html">command_base.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a32623fde3e73ebc22be14bfc3d891b" id="r_a1a32623fde3e73ebc22be14bfc3d891b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a1a32623fde3e73ebc22be14bfc3d891b">Robot</a> (std::string urdf_path, std::string can_interface, std::string direction=&quot;down&quot;, double vel=M_PI, std::string end_mode=&quot;teacher&quot;, std::string forearm_type=&quot;DM&quot;, bool factory=false)</td></tr>
<tr class="memdesc:a1a32623fde3e73ebc22be14bfc3d891b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classarm_1_1Robot.html" title="The Robot class for controlling the robot arm.">Robot</a> object.  <br /></td></tr>
<tr class="separator:a1a32623fde3e73ebc22be14bfc3d891b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cb84fbad8e67905b21da4e893b996c" id="r_a08cb84fbad8e67905b21da4e893b996c"><td class="memItemLeft" align="right" valign="top">Frame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a08cb84fbad8e67905b21da4e893b996c">get_current_pose</a> () const</td></tr>
<tr class="memdesc:a08cb84fbad8e67905b21da4e893b996c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current end pose in Cartesian space.  <br /></td></tr>
<tr class="separator:a08cb84fbad8e67905b21da4e893b996c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef49673214ad4c10f17d56f735317ba" id="r_a2ef49673214ad4c10f17d56f735317ba"><td class="memItemLeft" align="right" valign="top">Joints&lt; DOF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a2ef49673214ad4c10f17d56f735317ba">get_current_joint_q</a> () const</td></tr>
<tr class="memdesc:a2ef49673214ad4c10f17d56f735317ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current joint positions in joint space.  <br /></td></tr>
<tr class="separator:a2ef49673214ad4c10f17d56f735317ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05e2b718590c0f528a320fd970a36cc" id="r_ab05e2b718590c0f528a320fd970a36cc"><td class="memItemLeft" align="right" valign="top">Joints&lt; DOF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ab05e2b718590c0f528a320fd970a36cc">get_current_joint_v</a> () const</td></tr>
<tr class="memdesc:ab05e2b718590c0f528a320fd970a36cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current joint velocities in joint space.  <br /></td></tr>
<tr class="separator:ab05e2b718590c0f528a320fd970a36cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb3e39aa6eb82ebee7e7ab0740f9b11" id="r_abcb3e39aa6eb82ebee7e7ab0740f9b11"><td class="memItemLeft" align="right" valign="top">Joints&lt; DOF &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#abcb3e39aa6eb82ebee7e7ab0740f9b11">get_current_joint_t</a> () const</td></tr>
<tr class="memdesc:abcb3e39aa6eb82ebee7e7ab0740f9b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current joint torques in joint space.  <br /></td></tr>
<tr class="separator:abcb3e39aa6eb82ebee7e7ab0740f9b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376d61f951c25be1715dfba492782a79" id="r_a376d61f951c25be1715dfba492782a79"><td class="memItemLeft" align="right" valign="top">Translation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a376d61f951c25be1715dfba492782a79">get_current_translation</a> () const</td></tr>
<tr class="memdesc:a376d61f951c25be1715dfba492782a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current rotation part of the end pose.  <br /></td></tr>
<tr class="separator:a376d61f951c25be1715dfba492782a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60efe5e165e55c7f8ffd0c73239f5e3a" id="r_a60efe5e165e55c7f8ffd0c73239f5e3a"><td class="memItemLeft" align="right" valign="top">Rotation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a60efe5e165e55c7f8ffd0c73239f5e3a">get_current_rotation</a> () const</td></tr>
<tr class="memdesc:a60efe5e165e55c7f8ffd0c73239f5e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current end effector position.  <br /></td></tr>
<tr class="separator:a60efe5e165e55c7f8ffd0c73239f5e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651fb04450923fba9df7f91bed850845" id="r_a651fb04450923fba9df7f91bed850845"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a651fb04450923fba9df7f91bed850845">get_current_end</a> () const</td></tr>
<tr class="memdesc:a651fb04450923fba9df7f91bed850845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current end effector position.  <br /></td></tr>
<tr class="separator:a651fb04450923fba9df7f91bed850845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731da1917690b471fb397e074699c3f8" id="r_a731da1917690b471fb397e074699c3f8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a731da1917690b471fb397e074699c3f8">get_sn</a> () const</td></tr>
<tr class="memdesc:a731da1917690b471fb397e074699c3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SN code of the robot arm.  <br /></td></tr>
<tr class="separator:a731da1917690b471fb397e074699c3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48154cc9bf2782ddd2e644d0b83b51d3" id="r_a48154cc9bf2782ddd2e644d0b83b51d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a48154cc9bf2782ddd2e644d0b83b51d3">set_target_pose</a> (const Frame &amp;target_pose, bool use_planning=true, double vel=DEFAULT_VEL, bool blocking=false)</td></tr>
<tr class="memdesc:a48154cc9bf2782ddd2e644d0b83b51d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target end pose of the robot arm in Cartesian space.  <br /></td></tr>
<tr class="separator:a48154cc9bf2782ddd2e644d0b83b51d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d3b6bfd91d83275f196a9ee11000f8" id="r_a34d3b6bfd91d83275f196a9ee11000f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a34d3b6bfd91d83275f196a9ee11000f8">set_target_pose</a> (const Translation &amp;target_translation, const Rotation &amp;target_rotation, bool use_planning=true, double vel=DEFAULT_VEL, bool blocking=false)</td></tr>
<tr class="memdesc:a34d3b6bfd91d83275f196a9ee11000f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target end pose of the robot arm in Cartesian space.  <br /></td></tr>
<tr class="separator:a34d3b6bfd91d83275f196a9ee11000f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc9e3628c1b4b34c1595280ec47c243" id="r_a6bc9e3628c1b4b34c1595280ec47c243"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a6bc9e3628c1b4b34c1595280ec47c243">set_target_translation</a> (const Translation &amp;target_translation, bool use_planning=true, double vel=DEFAULT_VEL, bool blocking=false)</td></tr>
<tr class="memdesc:a6bc9e3628c1b4b34c1595280ec47c243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target translation of the robot arm in Cartesian space.  <br /></td></tr>
<tr class="separator:a6bc9e3628c1b4b34c1595280ec47c243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468ac3f9e11882b5f43fc9ba05cbec28" id="r_a468ac3f9e11882b5f43fc9ba05cbec28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a468ac3f9e11882b5f43fc9ba05cbec28">add_target_translation</a> (const Translation &amp;target_d_translation, bool use_planning=true, double vel=DEFAULT_VEL, bool blocking=false)</td></tr>
<tr class="memdesc:a468ac3f9e11882b5f43fc9ba05cbec28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target relative translation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative translation to the current planning target.  <br /></td></tr>
<tr class="separator:a468ac3f9e11882b5f43fc9ba05cbec28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35e09aeb7faf4c3bdab2cd2ecd79f8c" id="r_ad35e09aeb7faf4c3bdab2cd2ecd79f8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ad35e09aeb7faf4c3bdab2cd2ecd79f8c">add_target_relative_translation</a> (const Translation &amp;target_d_translation, bool use_planning=true, double vel=DEFAULT_VEL, bool blocking=false)</td></tr>
<tr class="memdesc:ad35e09aeb7faf4c3bdab2cd2ecd79f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target relative translation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative translation to the current planning target. The addition is performed in <b>the base frame</b>.  <br /></td></tr>
<tr class="separator:ad35e09aeb7faf4c3bdab2cd2ecd79f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8fb0dab4600451719b0979799ad3bb" id="r_a0a8fb0dab4600451719b0979799ad3bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a0a8fb0dab4600451719b0979799ad3bb">add_target_relative_rotation</a> (const Rotation &amp;target_d_rotation, bool use_planning=true, double vel=DEFAULT_VEL, bool blocking=false)</td></tr>
<tr class="memdesc:a0a8fb0dab4600451719b0979799ad3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target rotation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative rotation to the current planning target. The addition is performed in <b>the base frame</b>.  <br /></td></tr>
<tr class="separator:a0a8fb0dab4600451719b0979799ad3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16ba8117b3ba864d887f3e16c61851f" id="r_ab16ba8117b3ba864d887f3e16c61851f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ab16ba8117b3ba864d887f3e16c61851f">set_target_rotation</a> (const Rotation &amp;target_rotation, bool use_planning=true, double vel=DEFAULT_VEL, bool blocking=false)</td></tr>
<tr class="memdesc:ab16ba8117b3ba864d887f3e16c61851f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target rotation of the robot arm in Cartesian space.  <br /></td></tr>
<tr class="separator:ab16ba8117b3ba864d887f3e16c61851f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a9fc00f01139ffc422b4d77cef3199" id="r_af7a9fc00f01139ffc422b4d77cef3199"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#af7a9fc00f01139ffc422b4d77cef3199">set_target_vel</a> (const Twist &amp;target_vel)</td></tr>
<tr class="memdesc:af7a9fc00f01139ffc422b4d77cef3199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Velocity control method. Set the target end velocities of the robot arm in Cartesian space.  <br /></td></tr>
<tr class="separator:af7a9fc00f01139ffc422b4d77cef3199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6c3e1bfcfdc8e0c5deda7274e65525" id="r_aed6c3e1bfcfdc8e0c5deda7274e65525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#aed6c3e1bfcfdc8e0c5deda7274e65525">set_target_joint_q</a> (const Joints&lt; DOF &gt; &amp;target_joint_q, bool use_planning=true, double vel=DEFAULT_VEL, bool blocking=false)</td></tr>
<tr class="memdesc:aed6c3e1bfcfdc8e0c5deda7274e65525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target joint positions of the robot arm in joint space.  <br /></td></tr>
<tr class="separator:aed6c3e1bfcfdc8e0c5deda7274e65525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e0ffb808b9a7333b80b64fb35e3523" id="r_ac5e0ffb808b9a7333b80b64fb35e3523"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ac5e0ffb808b9a7333b80b64fb35e3523">add_target_joint_q</a> (const Joints&lt; DOF &gt; &amp;target_d_joint_q, bool use_planning=true, double vel=DEFAULT_VEL, bool blocking=false)</td></tr>
<tr class="memdesc:ac5e0ffb808b9a7333b80b64fb35e3523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target joint positions of the robot arm in joint space. The robot will move to the target pose by adding the relative joint positions to the current planning target joint position targets.  <br /></td></tr>
<tr class="separator:ac5e0ffb808b9a7333b80b64fb35e3523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3dfa5d140b73084ef53614d05bf0a0" id="r_a1b3dfa5d140b73084ef53614d05bf0a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a1b3dfa5d140b73084ef53614d05bf0a0">set_target_joint_v</a> (const Joints&lt; DOF &gt; &amp;target_joint_v)</td></tr>
<tr class="memdesc:a1b3dfa5d140b73084ef53614d05bf0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Velocity control method. Set the target joint velocities of the robot arm in joint space.  <br /></td></tr>
<tr class="separator:a1b3dfa5d140b73084ef53614d05bf0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca43059d150d8f214dc37d3d055fa19" id="r_a7ca43059d150d8f214dc37d3d055fa19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a7ca43059d150d8f214dc37d3d055fa19">add_target_joint_v</a> (const Joints&lt; DOF &gt; &amp;target_d_joint_v)</td></tr>
<tr class="memdesc:a7ca43059d150d8f214dc37d3d055fa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Velocity control method. Set the target joint velocities of the robot arm in joint space. The robot will accelerate / decelerate to target joint velocities by adding the relative joint velocities to the current joint velocity targets.  <br /></td></tr>
<tr class="separator:a7ca43059d150d8f214dc37d3d055fa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c33dacfa39dfbe3cfab2c012d5c4c73" id="r_a9c33dacfa39dfbe3cfab2c012d5c4c73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a9c33dacfa39dfbe3cfab2c012d5c4c73">set_target_joint_mit</a> (const Joints&lt; DOF &gt; &amp;target_joint_q, const Joints&lt; DOF &gt; &amp;target_joint_v, const Joints&lt; DOF &gt; &amp;target_joint_kp, const Joints&lt; DOF &gt; &amp;target_joint_kd, const Joints&lt; DOF &gt; &amp;target_joint_t)</td></tr>
<tr class="memdesc:a9c33dacfa39dfbe3cfab2c012d5c4c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT control method. Set the target joint positions, velocities, kp, kd and feed-forward torques of the motors of the arm. This mode enables force control of the robot arm.  <br /></td></tr>
<tr class="separator:a9c33dacfa39dfbe3cfab2c012d5c4c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7198901d16fd482770901e7c6af6a50" id="r_ae7198901d16fd482770901e7c6af6a50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ae7198901d16fd482770901e7c6af6a50">set_target_joint_mit</a> (const Joints&lt; DOF &gt; &amp;target_joint_q, const Joints&lt; DOF &gt; &amp;target_joint_v, const Joints&lt; DOF &gt; &amp;target_joint_kp, const Joints&lt; DOF &gt; &amp;target_joint_kd)</td></tr>
<tr class="memdesc:ae7198901d16fd482770901e7c6af6a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT control method. Set the target joint positions, velocities, kp, kd and feed-forward torques of the motors of the arm. This mode enables force control of the robot arm.  <br /></td></tr>
<tr class="separator:ae7198901d16fd482770901e7c6af6a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af964341d633cfd7dbdb3f00ee3fecada" id="r_af964341d633cfd7dbdb3f00ee3fecada"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#af964341d633cfd7dbdb3f00ee3fecada">set_target_end</a> (const double &amp;end_pose, bool blocking=false)</td></tr>
<tr class="memdesc:af964341d633cfd7dbdb3f00ee3fecada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target end position of the robot arm. The end position is a normalized value between 0 and 1, where 0 denotes that the end effector is closed and 1 denotes that the end effector is open.  <br /></td></tr>
<tr class="separator:af964341d633cfd7dbdb3f00ee3fecada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392fa9e5086b6502ae11c62ee380accc" id="r_a392fa9e5086b6502ae11c62ee380accc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a392fa9e5086b6502ae11c62ee380accc">record_start</a> ()</td></tr>
<tr class="memdesc:a392fa9e5086b6502ae11c62ee380accc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording the trajectory of the robot arm.  <br /></td></tr>
<tr class="separator:a392fa9e5086b6502ae11c62ee380accc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56db83113e20325e99bc58899666ef0" id="r_ac56db83113e20325e99bc58899666ef0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ac56db83113e20325e99bc58899666ef0">record_stop</a> ()</td></tr>
<tr class="memdesc:ac56db83113e20325e99bc58899666ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop recording the trajectory of the robot arm.  <br /></td></tr>
<tr class="separator:ac56db83113e20325e99bc58899666ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a49e03276cd2a9a5a3377f54e2bb977" id="r_a5a49e03276cd2a9a5a3377f54e2bb977"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a5a49e03276cd2a9a5a3377f54e2bb977">replay_start</a> ()</td></tr>
<tr class="memdesc:a5a49e03276cd2a9a5a3377f54e2bb977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replay the recorded / loaded trajectory of the robot arm.  <br /></td></tr>
<tr class="separator:a5a49e03276cd2a9a5a3377f54e2bb977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ebe3974b36a1e0709732dc8c9ec40c" id="r_a58ebe3974b36a1e0709732dc8c9ec40c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a58ebe3974b36a1e0709732dc8c9ec40c">manual_mode</a> ()</td></tr>
<tr class="memdesc:a58ebe3974b36a1e0709732dc8c9ec40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter manual mode. The robot be able to be dragged by hand.  <br /></td></tr>
<tr class="separator:a58ebe3974b36a1e0709732dc8c9ec40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0909c8ab84325abbeb1aa196115fa3f6" id="r_a0909c8ab84325abbeb1aa196115fa3f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a0909c8ab84325abbeb1aa196115fa3f6">offline_mode</a> ()</td></tr>
<tr class="memdesc:a0909c8ab84325abbeb1aa196115fa3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter the offline mode. The robot will stop moving and waiting for replay command.  <br /></td></tr>
<tr class="separator:a0909c8ab84325abbeb1aa196115fa3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e104211c880b0038dca59a573cd3529" id="r_a0e104211c880b0038dca59a573cd3529"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a0e104211c880b0038dca59a573cd3529">online_mode</a> ()</td></tr>
<tr class="memdesc:a0e104211c880b0038dca59a573cd3529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter the online mode. The robot will be able to be controlled by external commands (e.g. set_target_joint_q)  <br /></td></tr>
<tr class="separator:a0e104211c880b0038dca59a573cd3529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52c7d4d152ee6132e304075a50fe569" id="r_af52c7d4d152ee6132e304075a50fe569"><td class="memItemLeft" align="right" valign="top"><a id="af52c7d4d152ee6132e304075a50fe569" name="af52c7d4d152ee6132e304075a50fe569"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset_error</b> ()</td></tr>
<tr class="memdesc:af52c7d4d152ee6132e304075a50fe569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to recover from error mode. <br /></td></tr>
<tr class="separator:af52c7d4d152ee6132e304075a50fe569"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a47389ca0df26b0c019bfedde5008bad3" id="r_a47389ca0df26b0c019bfedde5008bad3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a47389ca0df26b0c019bfedde5008bad3">_update_once</a> ()</td></tr>
<tr class="separator:a47389ca0df26b0c019bfedde5008bad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;std::size_t DOF&gt;<br />
class arm::Robot&lt; DOF &gt;</div><p>The <a class="el" href="classarm_1_1Robot.html" title="The Robot class for controlling the robot arm.">Robot</a> class for controlling the robot arm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DOF</td><td>the number of degrees of freedom of the robot arm</td></tr>
  </table>
  </dd>
</dl>
<ol type="1">
<li>plug-to-play</li>
<li>control mode and light effect</li>
<li>Demonstrate Mode / Replay Mode / Online Mode </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1a32623fde3e73ebc22be14bfc3d891b" name="a1a32623fde3e73ebc22be14bfc3d891b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a32623fde3e73ebc22be14bfc3d891b">&#9670;&#160;</a></span>Robot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::Robot </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>urdf_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>can_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>direction</em> = <code>&quot;down&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>M_PI</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>end_mode</em> = <code>&quot;teacher&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>forearm_type</em> = <code>&quot;DM&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>factory</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classarm_1_1Robot.html" title="The Robot class for controlling the robot arm.">Robot</a> object. </p>
<p>Once created, the instance will perform the following actions:</p>
<ol type="1">
<li>initialize forward and inverse kinematics solvers</li>
<li>initialize text-based loggers; logs will be saved in the <code>logs</code> directory</li>
<li>initialize and check the status of the base interface board</li>
<li>initialize and check the status of the motors, from the base to the end</li>
<li>initialize and check the status of the end interface board</li>
<li>update motor status</li>
<li>start the following threads:<ul>
<li>thread_sync_pose_: map joints to end pose</li>
<li>thread_update_motor_: send CAN messages to motors</li>
<li>thread_plan_: perform planning</li>
<li>thread_log_: start pushing robot status to Kibana</li>
<li>thread_snap_: start listening to the snap signals. will be removed in the future</li>
</ul>
</li>
<li>unlock the motors</li>
</ol>
<p>Typically, the instance should be created once and used throughout the program. Also, it is the user's responsibility to ensure that <b>ONLY ONE</b> instance is controlling the robot at a time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">urdf_path</td><td>the path to valid AIRBOT Play URDF File. By default, when installed via apt package, two valid urdf files are installed:<ul>
<li>AIRBOT Play with no end effector: <code>/usr/local/share/airbot_play/airbot_play_v2_1/urdf/airbot_play_v2_1.urdf</code></li>
<li>AIRBOT Play with AIRBOT Play demonstrator: <code>/usr/local/share/airbot_play/airbot_play_v2_1/urdf/airbot_play_v2_1_with_gripper.urdf</code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">can_interface</td><td>the interface recognized by the system. Usually in the form like <code>can0</code>, <code>can1</code>, etc. The currently available interfaces can be found by <code>ip link</code> command, given that <code>iproute2</code> package is installed on Debian-based systems </td></tr>
    <tr><td class="paramname">direction</td><td>the direction of the gravity. If AIRBOT Play is installed on a vertical surface, this option should be altered. Available options: "down", "left", "right" </td></tr>
    <tr><td class="paramname">vel</td><td>the maximum velocity of joints in Online / Replay mode. </td></tr>
    <tr><td class="paramname">end_mode</td><td>the end effector installed at the end. Available options:<ul>
<li><code>none</code>: no end effector is installed</li>
<li><code>gripper</code>: AIRBOT Gripper is installed</li>
<li><code>newteacher</code>: AIRBOT Demonstrator is installed </li>
</ul>
</td></tr>
    <tr><td class="paramname">forearm_tpe</td><td>the type of the forearm. Available options:<ul>
<li><code>DM</code>: Damiao motors are installed</li>
<li><code>OD</code>: Self-designed motors are installed </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a47389ca0df26b0c019bfedde5008bad3" name="a47389ca0df26b0c019bfedde5008bad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47389ca0df26b0c019bfedde5008bad3">&#9670;&#160;</a></span>_update_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::_update_once </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect command from critical section</p>
<p>Update control frequency</p>
<p>Collect feedback data from motor drivers and calculate current pose</p>
<p>Automatically triggered mode changes</p>
<p>Snap triggered mode changes</p>
<p>External observations and actions have been properly handled, now proceed to actions</p>
<p>If planning is enabled and plan_params are valid, execute the planned trajectory cmd_data will be updated according to the planned trajectory</p>
<p>Calculating required torque for gravity compensation</p>
<p>Logging before executing the command</p>
<p>Actual command execution</p>

</div>
</div>
<a id="ac5e0ffb808b9a7333b80b64fb35e3523" name="ac5e0ffb808b9a7333b80b64fb35e3523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e0ffb808b9a7333b80b64fb35e3523">&#9670;&#160;</a></span>add_target_joint_q()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::add_target_joint_q </td>
          <td>(</td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_d_joint_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>DEFAULT_VEL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target joint positions of the robot arm in joint space. The robot will move to the target pose by adding the relative joint positions to the current planning target joint position targets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_d_joint_q</td><td>the target relative joint positions in radians. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">vel</td><td>the velocity when reaching the target </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="a7ca43059d150d8f214dc37d3d055fa19" name="a7ca43059d150d8f214dc37d3d055fa19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca43059d150d8f214dc37d3d055fa19">&#9670;&#160;</a></span>add_target_joint_v()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::add_target_joint_v </td>
          <td>(</td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_d_joint_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Velocity control method. Set the target joint velocities of the robot arm in joint space. The robot will accelerate / decelerate to target joint velocities by adding the relative joint velocities to the current joint velocity targets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_joint_v</td><td>the target joint velocities in radians per second. </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="a0a8fb0dab4600451719b0979799ad3bb" name="a0a8fb0dab4600451719b0979799ad3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8fb0dab4600451719b0979799ad3bb">&#9670;&#160;</a></span>add_target_relative_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::add_target_relative_rotation </td>
          <td>(</td>
          <td class="paramtype">const Rotation &amp;&#160;</td>
          <td class="paramname"><em>target_d_rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>DEFAULT_VEL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target rotation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative rotation to the current planning target. The addition is performed in <b>the base frame</b>. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_d_rotation</td><td>the target relative rotation in quaternion format <code>( rx, ry, rz, rw )</code>. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">vel</td><td>the velocity when reaching the target </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="ad35e09aeb7faf4c3bdab2cd2ecd79f8c" name="ad35e09aeb7faf4c3bdab2cd2ecd79f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35e09aeb7faf4c3bdab2cd2ecd79f8c">&#9670;&#160;</a></span>add_target_relative_translation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::add_target_relative_translation </td>
          <td>(</td>
          <td class="paramtype">const Translation &amp;&#160;</td>
          <td class="paramname"><em>target_d_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>DEFAULT_VEL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target relative translation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative translation to the current planning target. The addition is performed in <b>the base frame</b>. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_d_translation</td><td>the target relative translation in quaternion format <code>( rx, ry, rz, rw )</code>. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">vel</td><td>the velocity when reaching the target </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="a468ac3f9e11882b5f43fc9ba05cbec28" name="a468ac3f9e11882b5f43fc9ba05cbec28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468ac3f9e11882b5f43fc9ba05cbec28">&#9670;&#160;</a></span>add_target_translation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::add_target_translation </td>
          <td>(</td>
          <td class="paramtype">const Translation &amp;&#160;</td>
          <td class="paramname"><em>target_d_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>DEFAULT_VEL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target relative translation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative translation to the current planning target. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_d_translation</td><td>the target relative translation in meters. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">vel</td><td>the velocity when reaching the target </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="a651fb04450923fba9df7f91bed850845" name="a651fb04450923fba9df7f91bed850845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651fb04450923fba9df7f91bed850845">&#9670;&#160;</a></span>get_current_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::get_current_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current end effector position. </p>
<p>The end effector position is a normalized value between 0 and 1, where 0 denotes that the end effector is closed and 1 denotes that the end effector is open.</p>
<dl class="section return"><dt>Returns</dt><dd>double: current end position in meters. </dd></dl>

</div>
</div>
<a id="a2ef49673214ad4c10f17d56f735317ba" name="a2ef49673214ad4c10f17d56f735317ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef49673214ad4c10f17d56f735317ba">&#9670;&#160;</a></span>get_current_joint_q()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Joints&lt; DOF &gt; <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::get_current_joint_q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current joint positions in joint space. </p>
<dl class="section return"><dt>Returns</dt><dd>Joints&lt;DOF&gt;: current joint positions in radians. </dd></dl>

</div>
</div>
<a id="abcb3e39aa6eb82ebee7e7ab0740f9b11" name="abcb3e39aa6eb82ebee7e7ab0740f9b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb3e39aa6eb82ebee7e7ab0740f9b11">&#9670;&#160;</a></span>get_current_joint_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Joints&lt; DOF &gt; <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::get_current_joint_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current joint torques in joint space. </p>
<dl class="section return"><dt>Returns</dt><dd>Joints&lt;DOF&gt;: current joint torques in Newton meters. </dd></dl>

</div>
</div>
<a id="ab05e2b718590c0f528a320fd970a36cc" name="ab05e2b718590c0f528a320fd970a36cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05e2b718590c0f528a320fd970a36cc">&#9670;&#160;</a></span>get_current_joint_v()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Joints&lt; DOF &gt; <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::get_current_joint_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current joint velocities in joint space. </p>
<dl class="section return"><dt>Returns</dt><dd>Joints&lt;DOF&gt;: current joint velocities in radians per second. </dd></dl>

</div>
</div>
<a id="a08cb84fbad8e67905b21da4e893b996c" name="a08cb84fbad8e67905b21da4e893b996c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cb84fbad8e67905b21da4e893b996c">&#9670;&#160;</a></span>get_current_pose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Frame <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::get_current_pose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current end pose in Cartesian space. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="section return"><dt>Returns</dt><dd>Frame: current end pose consisting of translation and quaternion rotation in <code>(( x, y, z ), ( rx, ry, rz, rw ))</code> format. </dd></dl>

</div>
</div>
<a id="a60efe5e165e55c7f8ffd0c73239f5e3a" name="a60efe5e165e55c7f8ffd0c73239f5e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60efe5e165e55c7f8ffd0c73239f5e3a">&#9670;&#160;</a></span>get_current_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Rotation <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::get_current_rotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current end effector position. </p>
<p>The end effector position is a normalized value between 0 and 1, where 0 denotes that the end effector is closed and 1 denotes that the end effector is open.</p>
<dl class="section return"><dt>Returns</dt><dd>Rotation: current end position in meters. </dd></dl>

</div>
</div>
<a id="a376d61f951c25be1715dfba492782a79" name="a376d61f951c25be1715dfba492782a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376d61f951c25be1715dfba492782a79">&#9670;&#160;</a></span>get_current_translation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Translation <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::get_current_translation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current rotation part of the end pose. </p>
<p>The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector. The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="section return"><dt>Returns</dt><dd>Translation: current rotation in quaternion format <code>( rx, ry, rz, rw )</code>. </dd></dl>

</div>
</div>
<a id="a731da1917690b471fb397e074699c3f8" name="a731da1917690b471fb397e074699c3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731da1917690b471fb397e074699c3f8">&#9670;&#160;</a></span>get_sn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::get_sn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the SN code of the robot arm. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string: the serial number of the robot arm. </dd></dl>

</div>
</div>
<a id="a58ebe3974b36a1e0709732dc8c9ec40c" name="a58ebe3974b36a1e0709732dc8c9ec40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ebe3974b36a1e0709732dc8c9ec40c">&#9670;&#160;</a></span>manual_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::manual_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enter manual mode. The robot be able to be dragged by hand. </p>
<dl class="section return"><dt>Returns</dt><dd>true if arm mode changes successfully. </dd></dl>

</div>
</div>
<a id="a0909c8ab84325abbeb1aa196115fa3f6" name="a0909c8ab84325abbeb1aa196115fa3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0909c8ab84325abbeb1aa196115fa3f6">&#9670;&#160;</a></span>offline_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::offline_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enter the offline mode. The robot will stop moving and waiting for replay command. </p>
<dl class="section return"><dt>Returns</dt><dd>true if arm mode changes successfully. </dd></dl>

</div>
</div>
<a id="a0e104211c880b0038dca59a573cd3529" name="a0e104211c880b0038dca59a573cd3529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e104211c880b0038dca59a573cd3529">&#9670;&#160;</a></span>online_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::online_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enter the online mode. The robot will be able to be controlled by external commands (e.g. set_target_joint_q) </p>
<dl class="section return"><dt>Returns</dt><dd>true if arm mode changes successfully. </dd></dl>

</div>
</div>
<a id="a392fa9e5086b6502ae11c62ee380accc" name="a392fa9e5086b6502ae11c62ee380accc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392fa9e5086b6502ae11c62ee380accc">&#9670;&#160;</a></span>record_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::record_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start recording the trajectory of the robot arm. </p>
<p>The robot will record the joint positions, velocities, and torques, as well as the end position, at each time step. The recorded data can be saved to a file and replayed later.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the recording is started successfully. </dd></dl>

</div>
</div>
<a id="ac56db83113e20325e99bc58899666ef0" name="ac56db83113e20325e99bc58899666ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56db83113e20325e99bc58899666ef0">&#9670;&#160;</a></span>record_stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::record_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop recording the trajectory of the robot arm. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the recording is stopped successfully. </dd></dl>

</div>
</div>
<a id="a5a49e03276cd2a9a5a3377f54e2bb977" name="a5a49e03276cd2a9a5a3377f54e2bb977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a49e03276cd2a9a5a3377f54e2bb977">&#9670;&#160;</a></span>replay_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::replay_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replay the recorded / loaded trajectory of the robot arm. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the replay is started successfully. </dd></dl>

</div>
</div>
<a id="af964341d633cfd7dbdb3f00ee3fecada" name="af964341d633cfd7dbdb3f00ee3fecada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af964341d633cfd7dbdb3f00ee3fecada">&#9670;&#160;</a></span>set_target_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::set_target_end </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>end_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target end position of the robot arm. The end position is a normalized value between 0 and 1, where 0 denotes that the end effector is closed and 1 denotes that the end effector is open. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end</td><td>the normalized target end position. </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="ae7198901d16fd482770901e7c6af6a50" name="ae7198901d16fd482770901e7c6af6a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7198901d16fd482770901e7c6af6a50">&#9670;&#160;</a></span>set_target_joint_mit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::set_target_joint_mit </td>
          <td>(</td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_kp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_kd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIT control method. Set the target joint positions, velocities, kp, kd and feed-forward torques of the motors of the arm. This mode enables force control of the robot arm. </p>
<dl class="section note"><dt>Note</dt><dd>The gravity compensation is included.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_joint_q</td><td>the target joint positions in radians. </td></tr>
    <tr><td class="paramname">target_joint_v</td><td>the target joint velocities in radians per second. </td></tr>
    <tr><td class="paramname">target_joint_kp</td><td>the target joint proportional gains. </td></tr>
    <tr><td class="paramname">target_joint_kd</td><td>the target joint derivative gains.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return true if the target is set successfully </dd></dl>

</div>
</div>
<a id="a9c33dacfa39dfbe3cfab2c012d5c4c73" name="a9c33dacfa39dfbe3cfab2c012d5c4c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c33dacfa39dfbe3cfab2c012d5c4c73">&#9670;&#160;</a></span>set_target_joint_mit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::set_target_joint_mit </td>
          <td>(</td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_kp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MIT control method. Set the target joint positions, velocities, kp, kd and feed-forward torques of the motors of the arm. This mode enables force control of the robot arm. </p>
<dl class="section note"><dt>Note</dt><dd>The gravity compensation is not included in the feed-forward torques.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_joint_q</td><td>the target joint positions in radians. </td></tr>
    <tr><td class="paramname">target_joint_v</td><td>the target joint velocities in radians per second. </td></tr>
    <tr><td class="paramname">target_joint_kp</td><td>the target joint proportional gains. </td></tr>
    <tr><td class="paramname">target_joint_kd</td><td>the target joint derivative gains. </td></tr>
    <tr><td class="paramname">target_joint_t</td><td>the target joint feed-forward torques.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return true if the target is set successfully </dd></dl>

</div>
</div>
<a id="aed6c3e1bfcfdc8e0c5deda7274e65525" name="aed6c3e1bfcfdc8e0c5deda7274e65525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6c3e1bfcfdc8e0c5deda7274e65525">&#9670;&#160;</a></span>set_target_joint_q()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::set_target_joint_q </td>
          <td>(</td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>DEFAULT_VEL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target joint positions of the robot arm in joint space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_joint_q</td><td>the target joint positions in radians. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">vel</td><td>the velocity when reaching the target </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="a1b3dfa5d140b73084ef53614d05bf0a0" name="a1b3dfa5d140b73084ef53614d05bf0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3dfa5d140b73084ef53614d05bf0a0">&#9670;&#160;</a></span>set_target_joint_v()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::set_target_joint_v </td>
          <td>(</td>
          <td class="paramtype">const Joints&lt; DOF &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Velocity control method. Set the target joint velocities of the robot arm in joint space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_joint_v</td><td>the target joint velocities in radians per second. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48154cc9bf2782ddd2e644d0b83b51d3" name="a48154cc9bf2782ddd2e644d0b83b51d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48154cc9bf2782ddd2e644d0b83b51d3">&#9670;&#160;</a></span>set_target_pose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::set_target_pose </td>
          <td>(</td>
          <td class="paramtype">const Frame &amp;&#160;</td>
          <td class="paramname"><em>target_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>DEFAULT_VEL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target end pose of the robot arm in Cartesian space. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_pose</td><td>the target pose in Cartesian space. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">vel</td><td>the velocity when reaching the target </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="a34d3b6bfd91d83275f196a9ee11000f8" name="a34d3b6bfd91d83275f196a9ee11000f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d3b6bfd91d83275f196a9ee11000f8">&#9670;&#160;</a></span>set_target_pose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::set_target_pose </td>
          <td>(</td>
          <td class="paramtype">const Translation &amp;&#160;</td>
          <td class="paramname"><em>target_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rotation &amp;&#160;</td>
          <td class="paramname"><em>target_rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>DEFAULT_VEL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target end pose of the robot arm in Cartesian space. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_translation</td><td>the target translation in meters. </td></tr>
    <tr><td class="paramname">target_rotation</td><td>the target rotation in quaternion format <code>( rx, ry, rz, rw )</code>. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">vel</td><td>the velocity when reaching the target </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="ab16ba8117b3ba864d887f3e16c61851f" name="ab16ba8117b3ba864d887f3e16c61851f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16ba8117b3ba864d887f3e16c61851f">&#9670;&#160;</a></span>set_target_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::set_target_rotation </td>
          <td>(</td>
          <td class="paramtype">const Rotation &amp;&#160;</td>
          <td class="paramname"><em>target_rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>DEFAULT_VEL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target rotation of the robot arm in Cartesian space. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_rotation</td><td>the target rotation in quaternion format <code>( rx, ry, rz, rw )</code>. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">vel</td><td>the velocity when reaching the target </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="a6bc9e3628c1b4b34c1595280ec47c243" name="a6bc9e3628c1b4b34c1595280ec47c243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc9e3628c1b4b34c1595280ec47c243">&#9670;&#160;</a></span>set_target_translation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::set_target_translation </td>
          <td>(</td>
          <td class="paramtype">const Translation &amp;&#160;</td>
          <td class="paramname"><em>target_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>DEFAULT_VEL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target translation of the robot arm in Cartesian space. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_translation</td><td>the target translation in meters. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">vel</td><td>the velocity when reaching the target </td></tr>
    <tr><td class="paramname">blocking</td><td>whether or not to block the current procedure call until the target is reached</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if not blocking, return true if the target is set successfully; if blocking, return true if the target is reached successfully. </dd></dl>

</div>
</div>
<a id="af7a9fc00f01139ffc422b4d77cef3199" name="af7a9fc00f01139ffc422b4d77cef3199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a9fc00f01139ffc422b4d77cef3199">&#9670;&#160;</a></span>set_target_vel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t DOF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarm_1_1Robot.html">arm::Robot</a>&lt; DOF &gt;::set_target_vel </td>
          <td>(</td>
          <td class="paramtype">const Twist &amp;&#160;</td>
          <td class="paramname"><em>target_vel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Velocity control method. Set the target end velocities of the robot arm in Cartesian space. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>This function is not implemented yet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_vel</td><td>the target end velocities in meters per second. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/airbot/command/<a class="el" href="command__base_8hpp_source.html">command_base.hpp</a></li>
<li>src/airbot/command/<b>command_base.cpp</b></li>
<li>src/airbot/command/<b>end_control.cpp</b></li>
<li>src/airbot/command/<b>joint_control.cpp</b></li>
<li>src/airbot/command/<b>replay.cpp</b></li>
<li>src/airbot/command/<b>update.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
