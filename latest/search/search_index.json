{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"manual/airbot-play/","title":"AIRBOT Play \u7528\u6237\u624b\u518c","text":""},{"location":"manual/airbot-play/#_1","title":"\u673a\u68b0\u81c2\u5305\u88c5\u6e05\u5355","text":"<ul> <li> \u56fe1.1 \u6e05\u5355\u56fe\u7247\uff08\u542b\u9009\u914d\u5957\u4ef6)</li> <li> \u5e8f\u53f7 \u540d\u79f0 \u6570\u91cf / \u5355\u4f4d \u5907\u6ce8 1 AIRBOT Play \u673a\u68b0\u81c2 1 \u53f0 2 \u5b89\u88c5\u5e95\u677f 1 \u4e2a 3 \u56fa\u5b9aC\u578b\u5939 2 \u4e2a 4 \u672b\u7aef\u8fde\u63a5\u4ef6 1 \u4e2a 5 USB \u6570\u636e\u7ebf 1 \u6839 6 \u7535\u6e90\u9002\u914d\u5668 1 \u4e2a 7 \u7535\u6e90\u7ebf 1 \u6839 8 \u87ba\u4e1d 1 \u5305 \u5305\u542b M3\u3001M4 \u89c4\u683c\u87ba\u4e1d 9 L \u578b\u6273\u624b 1 \u5957 \u5305\u542b M3\u3001M4 \u89c4\u683c\u6273\u624b 10 \u6807\u96f6\u5de5\u5177 1 \u4e2a 11 \u793a\u6559\u5668 1 \u5957 \u9009\u914d\uff0c\u542b\u8fde\u63a5\u7ebf 12 \u5939\u722a 1 \u5957 \u9009\u914d\uff0c\u542b\u8fde\u63a5\u7ebf <p>\u88681.1 \u6e05\u5355\u8868\u683c</p> </li> </ul> <p>\u6280\u672f\u53c2\u6570</p> <ul> <li> \u81ea\u7531\u5ea6 6 \u91cd\u91cf 3.5 kg \u6700\u5927\u8d1f\u8f7d 15 kg \u6700\u5927\u81c2\u5c55 647 mm \u7535\u6e90\u8f93\u5165 24 V \u00b1 5%, 10 A \u901a\u4fe1\u63a5\u53e3 USB, COM \u63a7\u5236\u6a21\u5f0f \u4f4d\u7f6e\u63a7\u5236\uff0c\u529b\u77e9\u63a7\u5236\uff0c\u901f\u5ea6\u63a7\u5236 SDK \u63a5\u53e3 C++, Python, ROS, ROS2, Web \u4e0a\u4f4d\u673a\u517c\u5bb9\u6027 x86-64, arm64 \u6700\u5927\u529f\u8017 240 W \u529b\u53cd\u9988 \u6709 </li> <li> \u5173\u8282\u7f16\u53f7 \u5173\u8282\u8fd0\u52a8\u8303\u56f4 \u5173\u8282\u6700\u5927\u901f\u5ea6 J1 [-180\u00b0, +120\u00b0] 180\u00b0/s J2 [ -170\u00b0, +10\u00b0] 180\u00b0/s J3 [ -5\u00b0, +180\u00b0] 180\u00b0/s J4 [-148\u00b0, +148\u00b0] 360\u00b0/s J5 [-100\u00b0, +100\u00b0] 360\u00b0/s J6 [-179\u00b0, +179\u00b0] 360\u00b0/s </li> </ul>"},{"location":"manual/airbot-play/#_2","title":"\u673a\u68b0\u81c2\u5b89\u88c5\u8bf4\u660e","text":""},{"location":"manual/airbot-play/#_3","title":"\u5355\u81c2\u5b89\u88c5","text":""},{"location":"manual/airbot-play/#_4","title":"\u5b89\u88c5\u5e76\u56fa\u5b9a\u5e95\u677f","text":"<ul> <li> <p>\u5b89\u88c5\u5e95\u677f</p> <p>\u53d6\u51fa\u81c2\u3001\u5e95\u677f\u3001m4\u87ba\u4e1d*4\u3001L\u578bM4\u6273\u624b\uff0c\u6839\u636e\u573a\u666f\u6309\u9700\u8981\u7684\u89d2\u5ea6\uff08\u6b63\u5b89\u88c5 / \u659c 45 \u5ea6\u5b89\u88c5\uff09\u5c06\u81c2\u56fa\u5b9a\u5728\u5e95\u677f\u4e0a\uff0c\u5982\u4e0b\u56fe\u6240\u793a\uff1a </p> <p> \u56fe2.1 \u5e95\u677f</p> <p> \u56fe2.2 \u6b63\u5b89\u88c5\u65b9\u5f0f</p> <p> \u56fe2.3 \u659c45\u5ea6\u5b89\u88c5\u65b9\u5f0f</p> </li> <li> <p>\u56fa\u5b9a\u5e95\u7248</p> <p>\u5728\u4f7f\u7528\u673a\u68b0\u81c2\u4e4b\u524d\uff0c\u9700\u8981\u5c06\u5e95\u677f\u56fa\u5b9a\u5728\u7a33\u56fa\u7684\u5e95\u5ea7\u4e0a\u3002</p> <p>\u968f\u673a\u68b0\u81c2\u9644\u5e26\u7684 C \u578b\u5939\u56fa\u5b9a\u65b9\u5f0f\u53ef\u7528\u4e8e\u5c06\u5e95\u677f\u56fa\u5b9a\u5728\u684c\u6cbf\uff0c\u5982\u4e0b\u56fe\u6240\u793a\uff1a</p> <p> \u56fe2.4 \u5e95\u677fC\u578b\u5939\u56fa\u5b9a\u65b9\u5f0f</p> <p>\u5e95\u677f\u4e5f\u53ef\u901a\u8fc7\u4e24\u4fa7\u7684 M5 \u901a\u5b54 * 4 \u5b89\u88c5\u56fa\u5b9a\u5728\u9700\u8981\u7684\u8bbe\u5907\u4e0a\uff0c\u5b54\u4f4d\u4e0e\u5c3a\u5bf8\u5982\u4e0b\u56fe\u6240\u793a\uff1a  </p> <p> \u56fe2.5 \u5e95\u677f\u5b54\u4f4d\u5c3a\u5bf8\u56fe </p> </li> </ul> <p>\u6ce8\u610f\uff1a</p> <p>\u5b89\u88c5\u540e\u5fc5\u987b\u786e\u5b9a\u673a\u68b0\u81c2\u5904\u4e8e\u5f00\u9614\u7a7a\u95f4\uff0c\u4ee5\u9632\u673a\u68b0\u81c2\u5728\u8fd0\u52a8\u65f6\u78b0\u649e\u5230\u5468\u56f4\u7684\u4eba\u6216\u7269\u54c1\u3002</p>"},{"location":"manual/airbot-play/#_5","title":"\u5b89\u88c5\u672b\u7aef\u8fde\u63a5\u4ef6","text":"<p>\u53d6\u51fa\u672b\u7aef\u8fde\u63a5\u4ef6\u3001M3 \u87ba\u4e1d * 3\u3001L \u578b\u6273\u624b\u5982\u4e0b\u56fe\uff1a  </p> <p></p> <p>\u56fe2.6 \u672b\u7aef\u8fde\u63a5\u4ef6\u53ca\u914d\u4ef6</p> <p>\u5c06\u672b\u7aef\u8fde\u63a5\u4ef6\u4e09\u4e2a\u56fa\u5b9a\u9500\u4e0e\u672b\u7aef\u7535\u673a\u5b89\u88c5\u5e76\u7528 M3 \u87ba\u4e1d * 3 \u56fa\u5b9a\uff0c\u5982\u4e0b\u56fe\uff1a  </p> <ul> <li> <p> \u56fe2.7 \u672b\u7aef\u8fde\u63a5\u4ef6\u56fa\u5b9a\u9500*3\u4f4d\u7f6e\u56fe</p> </li> <li> <p> \u56fe2.8 \u672b\u7aef\u8fde\u63a5\u4ef6\u56fa\u5b9a\u5b8c\u6210\u56fe</p> </li> </ul>"},{"location":"manual/airbot-play/#_6","title":"\u5b89\u88c5\u5939\u722a\u6216\u793a\u6559\u5668 \u3010\u9009\u914d\u5957\u4ef6\u3011","text":"<ul> <li> <p>\u5b89\u88c5\u5939\u722a</p> <p>\u53d6\u51fa\u5939\u722a\u3001M4\u87ba\u4e1d * 4\uff0c\u5982\u4e0b\u4e3a\u5939\u722a\u4e0e\u8fde\u63a5\u4ef6\u56fa\u5b9a\u4f4d\uff0c\u5c06\u8be5\u653e\u5165\u672b\u7aef\u8fde\u63a5\u4ef6\u4e2d\uff0c\u56fa\u5b9a\u5b89\u88c5\u3002  </p> <p> \u56fe2.9 \u5939\u722a\u7535\u673a\u8fde\u63a5\u56fa\u5b9a\u4f4d\u7f6e\u56fe</p> <p> \u56fe2.10 \u5939\u722a\u87ba\u4e1d\u4f4d\u7f6e\u56fe</p> <p>\u53d6\u51fa\u5939\u722a\u914d\u5957\u7684\u8fde\u63a5\u7ebf</p> <p> \u56fe2.11 \u5939\u722a\u8fde\u63a5\u7ebf</p> <p>\u627e\u5230\u5982\u4e0b\u56fe\u6240\u793a\u7535\u6e90\u63d2\u53e3\u5b89\u88c5\uff0c</p> <p>\u6ce8\u610f\uff1a</p> <p>\u907f\u514d\u5f3a\u884c\u62c9\u62fd\u7ebf\uff0c\u9020\u6210\u63a5\u89e6\u4e0d\u826f\uff0c\u5b89\u88c5\u6216\u53d6\u4e0b\u65f6\u62d4\u63d2\u4e24\u4e2a\u7aef\u53e3\u5904\u3002</p> <p> \u56fe2.12 \u5939\u722a\u5b89\u88c5\u63d2\u53e3\u56fe</p> <p> \u56fe2.13 \u5939\u722a\u5b89\u88c5\u5b9e\u7269\u56fe</p> </li> <li> <p>\u5b89\u88c5\u793a\u6559\u5668</p> <p>\u53d6\u51fa\u793a\u6559\u5668\u3001M4\u87ba\u4e1d*4\uff0c\u5982\u4e0b\u4e3a\u793a\u6559\u5668\u4e0e\u8fde\u63a5\u4ef6\u56fa\u5b9a\u4f4d\uff0c\u5c06\u8be5\u653e\u5165\u672b\u7aef\u8fde\u63a5\u4ef6\u4e2d\uff0c\u56fa\u5b9a\u5b89\u88c5\u3002  </p> <p> \u56fe2.14 \u793a\u6559\u5668\u7535\u673a\u8fde\u63a5\u56fa\u5b9a\u4f4d\u7f6e\u56fe</p> <p> \u56fe2.15 \u793a\u6559\u5668\u87ba\u4e1d\u4f4d\u7f6e\u56fe</p> <p>\u53d6\u51fa\u793a\u6559\u5668\u914d\u5957\u7684\u8fde\u63a5\u7ebf</p> <p> \u56fe2.16 \u793a\u6559\u5668\u8fde\u63a5\u7ebf</p> <p>\u627e\u5230\u5982\u4e0b\u56fe\u6240\u793a\u7535\u6e90\u63d2\u53e3\u5b89\u88c5</p> <p>\u6ce8\u610f\uff1a</p> <p>\u907f\u514d\u5f3a\u884c\u62c9\u62fd\u7ebf\uff0c\u9020\u6210\u63a5\u89e6\u4e0d\u826f\uff0c\u5b89\u88c5\u6216\u53d6\u4e0b\u65f6\u62d4\u63d2\u4e24\u4e2a\u7aef\u53e3\u5904\u3002</p> <p> \u56fe2.17 \u793a\u6559\u5668\u5b89\u88c5\u63d2\u53e3\u56fe</p> <p> \u56fe2.18 \u793a\u6559\u5668\u5b89\u88c5\u5b9e\u7269\u56fe</p> </li> </ul>"},{"location":"manual/airbot-play/#_7","title":"\u673a\u68b0\u81c2\u4f7f\u7528\u8bf4\u660e","text":""},{"location":"manual/airbot-play/#_8","title":"\u5e95\u5ea7\u9762\u677f","text":"<ul> <li> <p> \u56fe3.1 \u673a\u68b0\u81c2\u9762\u677f</p> </li> <li> <ul> <li>\u7ea2\u6846\u90e8\u5206\u662f\u5f00\u673a\u952e\uff0c\u957f\u63093s\u5de6\u53f3\u5f85\u6307\u793a\u706f\u6761\u9ec4\u8272\u706f\u73e0\u4f9d\u6b21\u5168\u90e8\u4eae\u8d77\uff0c\u7b49\u5f85\u9ec4\u706f\u5168\u4eae\u53d8\u6210\u767d\u706f\u5168\u4eae\u540e\u5b8c\u6210\u5f00\u673a</li> <li>\u7ea2\u6846\u90e8\u5206\u662f\u5173\u673a\u952e\uff0c\u957f\u63093s\u5de6\u53f3\u5f85\u6307\u793a\u706f\u6761\u9ec4\u8272\u706f\u73e0\u4f9d\u6b21\u5168\u90e8\u7184\u706d\uff0c\u5b8c\u6210\u5173\u673a</li> <li>\u7eff\u6846\u90e8\u5206\u662f\u7535\u6e90\u63a5\u53e3</li> <li>\u84dd\u6846\u90e8\u5206\u662f\u901a\u4fe1\u63a5\u53e3</li> </ul> <p>USB</p> <p>USB-1 (TypeC) \u63a5\u53e3\u7528\u4e8e\u8fde\u63a5\u76f8\u673a\uff0c\u7528\u4e8e\u89c6\u89c9\u4f20\u611f\u5668\u6570\u636e\u4f20\u8f93\u3002</p> <p>USB-2 (TypeC) \u63a5\u53e3\u7528\u4e8e\u8fde\u63a5\u4e0a\u4f4d\u673a\uff0c\u7528\u4e8e\u6570\u636e\u4f20\u8f93\u548c\u63a7\u5236\u3002</p> </li> </ul>"},{"location":"manual/airbot-play/#_9","title":"\u5f00\u673a\u4e0e\u6807\u96f6","text":""},{"location":"manual/airbot-play/#_10","title":"\u51c6\u5907\u7535\u8111","text":"<p>\u5728 Ubuntu 20.04 \u7cfb\u7edf\u5b89\u88c5\u6700\u65b0\u7684\u673a\u68b0\u81c2\u8f6f\u4ef6\u5305\uff0c\u5e76\u914d\u7f6e\u597d\u73af\u5883\uff0c\u5b89\u88c5 <code>airbot_play</code> \u4e0e <code>airbot_tools</code> \u4e24\u4e2a\u8f6f\u4ef6\u5305</p>"},{"location":"manual/airbot-play/#_11","title":"\u6807\u96f6","text":"<ul> <li> <p> \u56fe3.2 \u6807\u96f6\u5de5\u5177</p> <p> \u56fe3.4 \u6807\u96f6\u673a\u68b0\u81c2\u5b9e\u7269\u56fe</p> </li> <li> <p>\u9996\u5148\u4f7f\u7528\u6570\u636e\u7ebf\u5c06\u7535\u8111\u4e0e\u673a\u68b0\u81c2 USB-2 \u8fde\u63a5\uff0c\u957f\u6309\u7535\u6e90\u952e 3s \u5de6\u53f3\u5f85\u6307\u793a\u706f\u6761\u9ec4\u8272\u706f\u73e0\u4f9d\u6b21\u5168\u90e8\u4eae\u8d77\uff0c\u7b49\u5f85\u9ec4\u706f\u5168\u4eae\u53d8\u6210\u767d\u706f\u5168\u4eae\u540e\u5b8c\u6210\u5f00\u673a\u3002</p> <p>\u8fd0\u884c <code>airbot_set_zero</code> \u547d\u4ee4\uff0c\u6309\u4ee3\u7801\u63d0\u793a\uff0c\u5c06\u6807\u96f6\u5de5\u5177\u653e\u5165 2 \u53f7\u5173\u8282\u5904\u3002\u6807\u96f6\u5de5\u5177\u9700\u8981\u7d27\u5bc6\u8d34\u5408 2 \u53f7\u5173\u8282\u7535\u673a\uff0c\u7ad6\u76f4\u5411\u4e0a\u653e\u7f6e\uff0c\u5c06\u673a\u68b0\u81c2\u56fa\u5b9a\u5728\u96f6\u4f4d\u3002</p> <p>\u653e\u7f6e\u5b8c\u6210\u540e\u6309\u56de\u8f66\uff0c\u7b49\u5f85\u673a\u68b0\u81c2\u5b8c\u6210\u6807\u96f6\uff1b\u6807\u96f6\u5b8c\u6210\u540e\u53ef\u5c06\u673a\u68b0\u81c2\u5c0f\u81c2\u62ac\u8d77\uff0c\u62ff\u51fa\u6807\u96f6\u5de5\u5177\uff0c\u968f\u540e\u518d\u6b21\u6309\u56de\u8f66\uff0c\u7b49\u5f85\u6807\u96f6\u7ed3\u675f\u3002</p> <p> \u56fe3.3 \u6807\u96f6\u5de5\u5177\u56fa\u5b9a\u4f4d\u7f6e\u56fe</p> </li> </ul>"},{"location":"manual/airbot-play/#_12","title":"\u706f\u6548","text":"<ul> <li><code>\u9ec4\u8272\u5168\u4eae</code>\uff1a\u7535\u6e90\u6309\u952e\u6309\u4e0b</li> <li><code>\u9ec4\u8272\u6d41\u6c34\u706f\uff08\u4ece\u5de6\u5f80\u53f3\u4eae\u8d77\uff09</code>\uff1a\u5f00\u673a\u4e2d</li> <li><code>\u9ec4\u8272\u6d41\u6c34\u706f\uff08\u4ece\u53f3\u5f80\u5de6\u7184\u706d\uff09</code>\uff1a\u5173\u673a\u4e2d</li> <li><code>\u9ec4\u8272\u547c\u5438\u706f</code>\uff1a\u4e0a\u7535\u81ea\u68c0\u4e2d</li> <li><code>\u767d\u8272\u547c\u5438\u706f</code>\uff1a\u8131\u673a\u72b6\u6001</li> <li><code>\u7eff\u8272\u547c\u5438\u706f</code>\uff1a\u952e\u76d8\u63a7\u5236\u6a21\u5f0f</li> <li><code>\u9752\u8272\u957f\u4eae</code>\uff1a\u91cd\u529b\u8865\u507f\u6a21\u5f0f</li> <li><code>\u84dd\u8272\u547c\u5438\u706f</code>\uff1a\u5f55\u5236\u4e2d</li> <li><code>\u7d2b\u8272\u957f\u4eae</code>\uff1a\u79bb\u7ebf\u6a21\u5f0f</li> <li><code>\u7d2b\u8272\u5feb\u95ea</code>\uff1a\u91cd\u653e\u6a21\u5f0f\uff08\u5230\u521d\u59cb\u4f4d\u7f6e\uff09</li> <li><code>\u7d2b\u8272\u547c\u5438\u706f</code>\uff1a\u8f68\u8ff9\u91cd\u653e\u4e2d</li> <li><code>\u9ec4\u8272\u5feb\u95ea</code>\uff1a\u7a0b\u5e8f\u9000\u51fa\u4e2d</li> <li><code>\u5f69\u8272\u6d41\u6c34\u706f</code>\uff1a\u70e7\u5f55\u56fa\u4ef6\u4e2d</li> </ul>"},{"location":"manual/airbot-play/#_13","title":"\u952e\u76d8\u63a7\u5236","text":"<p>\u8fd0\u884c\u952e\u76d8\u63a7\u5236\u5de5\u5177\uff0c\u673a\u68b0\u81c2\u8fdb\u5165\u53d7\u63a7\u72b6\u6001\uff1a</p> <pre><code>airbot_play_node\n</code></pre> <p>\u5728\u8be5\u72b6\u6001\u4e0b\uff1a</p> <ul> <li>\u70b9\u6309\u952e\u76d8 <code>W</code> / <code>A</code> / <code>S</code> / <code>D</code> / <code>Q</code> / <code>E</code> \u63a7\u5236\u673a\u68b0\u81c2\u524d\u540e\u5de6\u53f3\u4e0a\u4e0b\u79fb\u52a8</li> <li>\u70b9\u6309\u952e\u76d8 <code>1</code> - <code>0</code> \u63a7\u5236\u5355\u4e2a\u5173\u8282\u987a\u9006\u65f6\u9488\u65cb\u8f6c</li> <li><code>[</code> \u4e0e <code>]</code> \u63a7\u5236\u5939\u722a\u5f00\u5408</li> <li>\u957f\u6309\u672b\u7aef\u6309\u952e\u8fdb\u5165\u91cd\u529b\u8865\u507f\u6a21\u5f0f\u3002\u5728\u8be5\u6a21\u5f0f\u4e0b\u673a\u68b0\u81c2\u53ef\u88ab\u81ea\u7531\u62d6\u52a8\uff1b\u5728\u8be5\u6a21\u5f0f\u4e0b\u77ed\u6309\u5e95\u5ea7\u6309\u952e\u5f00\u59cb / \u505c\u6b62\u5f55\u5236\u52a8\u4f5c</li> <li>\u53cc\u51fb\u672b\u7aef\u6309\u952e\u8fdb\u5165\u91cd\u653e\u5f85\u673a\u6a21\u5f0f\u3002\u5728\u8be5\u6a21\u5f0f\u4e0b\uff0c\u77ed\u6309\u5e95\u5ea7\u6309\u952e\u5f00\u59cb\u91cd\u653e\u52a8\u4f5c</li> <li><code>Ctrl+C</code> \u6216 <code>Z</code> \u9000\u51fa\u7a0b\u5e8f</li> </ul> <p>\u5176\u4ed6\u63a7\u5236\u5de5\u5177\u8be6\u89c1 AIRBOT Tools</p>"},{"location":"manual/airbot-play/#faq","title":"FAQ","text":"AIRBOT Play \u673a\u68b0\u81c2\u76f8\u6bd4\u4e8e\u540c\u7c7b\u578b\u7684\u534f\u4f5c\u81c2\u7684\u4f18\u52bf\u662f\u4ec0\u4e48\uff1f <ul> <li>\u4f53\u79ef\u5c0f\uff0c\u6ca1\u6709\u5916\u7f6e\u63a7\u5236\u67dc\uff0c\u65b9\u4fbf\u96c6\u6210</li> <li>\u91cd\u91cf\u8f7b\uff0c\u81ea\u91cd\u4ec53.5kg\uff0c\u53ef\u7528\u4e8e\u5404\u79cd\u5c0f\u578b\u79fb\u52a8\u5e73\u53f0\uff08\u56db\u8db3\u3001\u8f6e\u8db3\u3001\u65e0\u4eba\u673a\u7b49\uff09\u3002</li> <li>AI+\uff0c\u517c\u5bb9ALOHA\u3001Mobile ALOHA\u3001 RT-X\u3001VoxPoser\u7b49\u5177\u8eab\u667a\u80fd\u524d\u6cbf\u5de5\u4f5c\uff0c\u501f\u52a9\u5927\u6a21\u578b\u7406\u89e3\u81ea\u7136\u8bed\u8a00\u6307\u4ee4\uff0c\u652f\u6301\u4e00\u952e\u573a\u666f\u626b\u63cf\u529f\u80fd\uff0c\u914d\u5408\u9ad8\u4fdd\u771f\u4eff\u771f\u5668\uff0c\u63d0\u9ad8\u673a\u68b0\u81c2\u667a\u80fd\u7a0b\u5ea6\u3002  </li> </ul> AIRBOT Play \u673a\u68b0\u81c2\u7684\u4f9b\u7535\u7535\u538b\u53ca\u7535\u6d41\u662f\u591a\u5c11\uff1f <p>AIRBOT Play\u7684\u4f9b\u7535\u7535\u538b\u8303\u56f4\u662f\u76f4\u6d41 24V\uff0c\u6700\u5927\u529f\u7387 240W\u3002\u4f9b\u7535\u8bbe\u5907\u6700\u597d\u80fd\u63d0\u4f9b\u77ac\u95f4\u6700\u592710A\u7684\u7535\u6d41\uff0c\u4ee5\u4f9b\u673a\u68b0\u81c2\u5728\u5404\u79cd\u5de5\u51b5\u4e0b\u4f7f\u7528\u3002 \u53ef\u4ee5\u4f7f\u7528\u914d\u4ef6\u4e2d\u7684\u7535\u6e90\u9002\u914d\u5668\u63a5\u5165\u5e02\u7535\u4f7f\u7528\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u63d0\u4f9b\u7684\u7535\u6e90\u7ebf\u8fde\u63a5\u7535\u6c60\u6216\u79fb\u52a8\u7535\u6e90\u4f9b\u7535\u3002 \u7535\u6e90\u9002\u914d\u5668\u7684\u63d2\u5934\u9632\u5446\uff0c\u6b63\u786e\u63d2\u6cd5\u89c1\u4e0b\u56fe\uff1a</p> <p></p> <p>\u56fe4.1 \u7535\u6e90\u8fde\u63a5\u56fe</p> AIRBOT Play\u673a\u68b0\u81c2\u7684\u672b\u7aef\u53ef\u4ee5\u63a5\u54ea\u4e9b\u6267\u884c\u5668\uff1f <p>\u5982\u679c\u662f CAN \u63a5\u53e3\u7684\u672b\u7aef\u6267\u884c\u5668\uff08\u5982\u6c42\u4e4b\u81ea\u7814\u5939\u722a AIRBOT Gripper\uff09\uff0c\u53ef\u4ee5\u4f7f\u75286\u53f7\u5173\u8282\u5904\u7684\u63a5\u53e3\uff1b\u8be5\u63a5\u53e3\u8f93\u51fa\u7535\u538b 24V\uff0c\u989d\u5b9a\u8f93\u51fa\u7535\u6d41 1.15A\u3002 \u5982\u679c\u662f RS485 \u63a5\u53e3\u7684\u672b\u7aef\u6267\u884c\u5668\uff0c\u53ef\u4ee5\u4f7f\u7528\u672b\u7aef\u677f\u7684 RS485 \u63a5\u53e3\uff0c\u8f93\u51fa\u7535\u538b 5V / 7V / 24V\uff0c\u989d\u5b9a\u8f93\u51fa\u7535\u6d41 1.15A\u3002  </p> AIRBOT Play\u673a\u68b0\u81c2\u7684\u672b\u7aef\u53ef\u4ee5\u63a5\u54ea\u4e9b\u76f8\u673a\uff1f <p>\u673a\u68b0\u81c2\u672b\u7aef\u677f\u7684 USB Type-C \u63a5\u53e3\u53ef\u4ee5\u76f4\u63a5\u8fde\u76f8\u673a\uff0c\u7136\u540e\u901a\u8fc7\u673a\u68b0\u81c2\u5e95\u5ea7\u677f\u7684 USB-1 (TypeC) \u63a5\u53e3\u8fde\u63a5\u4e0a\u4f4d\u673a\uff0c\u5b9e\u73b0\u76f8\u673a\u7684\u5185\u90e8\u8d70\u7ebf\u6570\u636e\u900f\u4f20\u3002 \u5df2\u6d4b\u8bd5\u53ef\u7528\u7684\u76f8\u673a\uff1a\u821c\u5b87\u3001\u94f6\u725b\u3001V4L2 \u76f8\u673a\uff1b\u652f\u6301\u76f8\u673a\u79cd\u7c7b\u4f1a\u6301\u7eed\u66f4\u65b0\u3002  </p> AIRBOT Play\u673a\u68b0\u81c2\u7684\u4e3b\u63a7\u5904\u7406\u5668\u662f\u4ec0\u4e48\uff1f <p>\u76ee\u524d\u7248\u672c\u7684 AIRBOT Play \u673a\u68b0\u81c2\u7531\u4e0a\u4f4d\u673a\u63a7\u5236\uff0c\u5373\u5c06\u53d1\u5e03\u7684AIRBOT Play Pro \u5c06\u91c7\u7528\u5185\u7f6e X5 \u5904\u7406\u5668\u3002</p> \u76ee\u524d\u652f\u6301\u7684\u4eff\u771f\u5e73\u53f0\u6709\u54ea\u4e9b\uff1f <p>\u76ee\u524d\u652f\u6301 Isaac Sim\u3001Gazebo \u7b49\u4eff\u771f\u5e73\u53f0\uff08\u6301\u7eed\u6dfb\u52a0\u4e2d\uff09\u3002</p> \u5939\u722a\u7684\u5939\u53d6\u7b97\u6cd5\u5305\u542b\u54ea\u4e9b\uff1f\u662f\u5426\u53ef\u4ee5\u63d0\u4f9b\uff1f <p>\u5305\u62ec Graspnet / Catgrasp \u7b49\u6a21\u5757\u5316\u6293\u53d6\u7b97\u6cd5\uff0c\u4ee5\u53ca voxposer \u7b49\u7aef\u5230\u7aef\u89c4\u5212\u6293\u53d6\u7b97\u6cd5\u3002 \u6211\u4eec\u53ef\u4ee5\u6839\u636e\u9700\u6c42\uff0c\u63d0\u4f9b\u76f8\u5173\u4ee3\u7801\u5305\u3002</p> \u591a\u6a21\u6001\u611f\u77e5\u5305\u542b\u54ea\u4e9b\uff1f\u662f\u5426\u53ef\u4ee5\u63d0\u4f9b\uff1f <p>\u591a\u6a21\u6001\u5305\u62ec\u672b\u7aef\u89c6\u89c9\u3001\u672b\u7aef\u89e6\u89c9\u3001\u73af\u5883\u8bed\u97f3\u3001\u573a\u666fSOP\u8bf4\u660e\u7b49\uff0c\u591a\u6a21\u6001\u611f\u77e5\u878d\u5408\u591a\u79cd\u73af\u5883\u4fe1\u606f\u8fdb\u884c\u957f\u7a0b\u4efb\u52a1\u6267\u884c\u3002 \u6211\u4eec\u53ef\u4ee5\u6839\u636e\u9700\u6c42\uff0c\u63d0\u4f9b\u76f8\u5173\u4ee3\u7801\u5305\u3002</p>"},{"location":"manual/airbot-play-pro/","title":"AIRBOT Play Pro \u7528\u6237\u624b\u518c","text":"<p>Coming soon</p> <p>\u656c\u8bf7\u671f\u5f85\uff01</p>"},{"location":"sdk/","title":"SDK for AIRBOT Play (Pro)","text":"<p>After extracting the firmware package, the directory structure is as follows: <pre><code>.\n\u251c\u2500\u2500 CHANGELOG\n\u251c\u2500\u2500 SHA1.txt\n\u251c\u2500\u2500 firmwares\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 BLDC_4_ChibiOS.bin                                   # ESC firmware\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 arm-interface-board-base.bin                         # Base interface board firmware \n\u2502\u00a0\u00a0 \u2514\u2500\u2500 end                                                  # End interface board firmware for different end effectors\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 arm-interface-board-end_desheng_servo.bin\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 arm-interface-board-end_jodell_2_fingers.bin\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 arm-interface-board-end_jodell_suction_cup.bin\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 arm-interface-board-end_yingshi_2_fingers.bin\n\u2514\u2500\u2500 packages\n    \u251c\u2500\u2500 airbot_aloha_2.8.3-291bbb4_amd64.deb                 # ALOHA example package, depends on the basic control library package\n    \u251c\u2500\u2500 airbot_play_2.8.3-a117c2fe_amd64.deb                 # Basic control library package, provides support for various interfaces\n    \u251c\u2500\u2500 airbot_tools_2.8.3-291bbb4_amd64.deb                 # Example tools package, depends on the basic control library package\n    \u251c\u2500\u2500 ros-noetic-ros-interface_2.8.3-0focal_amd64.deb      # ROS Interface package, depends on the basic control library package\n    \u2514\u2500\u2500 sdk-develop-python.zip\n</code></pre></p> <p>The AIRBOT Play supports provide SDK for:</p> <ol> <li>C++ </li> <li>Python (3.8, documents in progress)</li> <li>ROS 1 Noetic</li> <li>ROS 2 Humble (In development)</li> </ol> <p>Also, two example projects are provided, <code>airbot_tools</code> and <code>airbot_aloha</code>.  The two projects are CMake projects built on top of C++ SDK.</p> <ol> <li> <p><code>airbot_tools</code>: A set of useful tools for the use of AIRBOT Play</p> <ul> <li><code>airbot_kbd_ctrl</code>: Basic keyboard control for AIRBOT Play</li> <li><code>airbot_sync</code>: Control two AIRBOT Play simultaneously, with one following the </li> <li><code>airbot_set_zero</code>: Set the current position as the zero position</li> </ul> </li> <li> <p><code>airbot_aloha</code>: Tools for collecting data for ALOHA algorithm training</p> <ul> <li><code>airbot_demonstrate</code>: Demostration for two AIRBOT Play (1 leader, 1 follower)</li> <li><code>airbot_demonstrate_dual</code>: Demostration for four AIRBOT Play (2 leaders, 2 followers)  </li> </ul> </li> </ol> <p>Detailed usage can be found by <code>--help</code> option in each tool. They will also be documented here in the future.</p>"},{"location":"sdk/ROS1/","title":"ROS 1 Interface","text":"<p>Supported ROS 1 Distribution</p> <p>The AIRBOT Play robotic arm are compatible with the following ROS 1 distributions and platforms:</p> <ul> <li>ROS 1 Noetic on Ubuntu Linux 20.04</li> </ul>"},{"location":"sdk/ROS1/#environment-setup","title":"Environment Setup","text":""},{"location":"sdk/ROS1/#install-latest-airbot_play-package","title":"Install latest <code>airbot_play</code> package","text":"<p><code>airbot_play</code> </p> <p>The <code>airbot_play</code> package is the core package of AIRBOT Play robotic arm. It provides the basic control library for the robotic arm.</p> <p>Download the deb package from releases of <code>arm-control</code>.  The package file name should be in the format of <code>airbot_play_&lt;version&gt;_&lt;arch&gt;.deb</code>.</p> <p>Then install the package with the following command: <pre><code># Run with root privileges\napt install ./airbot_play_&lt;version&gt;_&lt;arch&gt;.deb\n</code></pre></p>"},{"location":"sdk/ROS1/#install-ros_interface-package","title":"Install <code>ros_interface</code> package","text":"<p><code>ros_interface</code> </p> <p>The <code>ros_interface</code> package is the ROS 1 interface for AIRBOT Play robotic arm.</p> <p>Download the deb package <code>ros_interface</code> from releases of <code>sdk</code>.  The package file name should be in the format of <code>ros-noetic-ros-interface_&lt;version&gt;-0focal_amd64.deb</code></p> <p>Then install the package with the following command: <pre><code># Run with root privileges\napt install ./ros-noetic-ros-interface_&lt;version&gt;-0focal_amd64.deb\n</code></pre></p>"},{"location":"sdk/ROS1/#optional-install-joystick-support","title":"(Optional) Install JoyStick Support","text":"<p>JoyStick Support</p> <p>The JoyStick support is optional. It provides the ability to control the robotic arm with a JoyStick.</p> <p>Run the following command to install ros packages for JoyStick support:</p> <pre><code># Run with root privileges:\napt install ros-noetic-joy ros-noetic-tf ros-noetic-kdl-parser\n</code></pre> <p>Now you can control AIRBOT Play via ROS 1 and JoyStick.</p>"},{"location":"sdk/ROS1/#usage","title":"Usage","text":""},{"location":"sdk/ROS1/#launch-ros-interface","title":"Launch ROS Interface","text":"<p>ROS 1 Environment</p> <p>Before launching the ROS interface, make sure you have set up the ROS 1 environment correctly. This is typically done by sourcing the <code>setup.bash</code> file: <pre><code># Bash\nsource /opt/ros/noetic/setup.bash\n# Zsh\nsource /opt/ros/noetic/setup.zsh\n</code></pre></p> <p>Launch the ROS interface with the following command: <pre><code>roslaunch ros_interface airbot_arm.launch [end_mode:=gripper] [urdf:=&lt;/path/to/urdf/file&gt;]\n</code></pre></p> <p>Launch Parameters</p> <ul> <li><code>end_mode</code>: The end mode of the robotic arm. The available options are <code>gripper</code>, <code>newtracher</code>, and <code>yinshi</code>. The URDF model of the robotic arm will be loaded according to the selected end mode.</li> <li><code>urdf</code>: If you wish to perform precise end control, a custom urdf file with <code>link6</code> as the target end can be specified with this parameter.</li> </ul>"},{"location":"sdk/ROS1/#ros-topic-reference","title":"ROS Topic Reference","text":""},{"location":"sdk/ROS1/#subscriber","title":"Subscriber","text":"<ol> <li> <p><code>/airbot_play/set_target_pose</code></p> <p>Topic type: <code>geometry_msgs::Pose</code>.</p> <p>Set the target gripping pose of the end effector (if end effector exists) or the center of the 6-th motor (if no end effector exists).</p> <p>The origin of the reference frame is the base of the robotic arm. X points to the front, Y points to the left, and Z points upwards. The orientation is represented by a quaternion representing the rotation from <code>(1, 0, 0)</code> to the target direction.</p> <p>If an invalid target pose is received by the robotic arm, the robotic arm will not move.</p> <p>A valid target pose published by <code>rostopic</code>: <pre><code>rostopic pub -1 /airbot_play/set_target_pose geometry_msgs/Pose \"position:\nx: 0.25\ny: 0.10\nz: 0.35\norientation:\nx: 0.0\ny: 0.707\nz: 0.0\nw: 0.707\"\n</code></pre></p> </li> <li> <p><code>/airbot_play/set_target_joint_q</code></p> <p>Topic type: <code>sensor_msgs::JointState</code>.</p> <p>Set the target joint angles of the robotic arm. The order of the joint angles should be consistent with the order of the joints in the URDF model (from the base to the end).</p> <p>Infomation other than the target joint angles will be ignored.</p> <p>If an invalid target joint angle is received by the robotic arm, the robotic arm will not move.</p> <p>An example of a valid target joint angle published by <code>rostopic</code>: <pre><code>rostopic pub -1 /airbot_play/set_target_joint_q sensor_msgs/JointState \"header:\nseq: 0\nstamp: {secs: 0, nsecs: 0}\nframe_id: ''\nname: ['']\nposition: [0, 0, 0, 0, 0, 0]\nvelocity: [0]\neffort: [0]\"\n</code></pre></p> </li> <li> <p><code>/airbot_play/set_target_joint_v</code></p> <p>Topic type: <code>sensor_msgs::JointState</code>.</p> <p>Set the target joint velocities of the robotic arm. The order of the joint velocities should be consistent with the order of the joints in the URDF model (from the base to the end).</p> <p>Infomation other than the target joint velocities will be ignored.</p> <p>If an invalid target joint velocity is received by the robotic arm, the robotic arm will not move.</p> <p>An example of a valid target joint velocity published by <code>rostopic</code>:</p> <pre><code>rostopic pub -1 /airbot_play/set_target_joint_v sensor_msgs/JointState \"header:\nseq: 0\nstamp: {secs: 0, nsecs: 0}\nframe_id: ''\nname: ['']\nposition: [0]\nvelocity: [0, 0, 0, 0, 0, 0]\neffort: [0]\"\n</code></pre> </li> <li> <p><code>/airbot_play/gripper/set_position</code></p> <p>Topic type: <code>std_msgs::Float64</code>.</p> <p>Set the target status of the gripper. The target status is a normalized value between <code>0</code> and <code>1</code> where <code>0</code> means close, <code>1</code> means open.</p> <p>If an invalid target status is received by the robotic arm, the gripper will not move.</p> <p>An example of a valid target status published by <code>rostopic</code>:</p> <pre><code>rostopic pub -1 /airbot_play/gripper/set_position std_msgs/Float64 \"data: 1.0\"\n</code></pre> </li> </ol>"},{"location":"sdk/ROS1/#publisher","title":"Publisher","text":"<ol> <li> <p><code>/airbot_play/end_pose</code></p> <p>Topic type: <code>geometry_msgs::Pose</code>.</p> <p>Publish the current pose of the end effector relative to the base of the robotic arm.</p> <p>The origin of the reference frame is the base of the robotic arm. X points to the front, Y points to the left, and Z points upwards. The orientation is represented by a quaternion representing the rotation from <code>(1, 0, 0)</code> to the target direction.</p> <p>An example of the published end pose:</p> <pre><code># rostopic echo -n 1 /airbot_play/end_pose\nposition:\n  x: 0.12846235946081982\n  y: -0.011717509217491769\n  z: 0.21345294013754434\norientation:\n  x: 0.0017778062709710638\n  y: 0.7131848423783093\n  z: 0.0019247148770529623\n  w: 0.7009711231422671\n---\n</code></pre> </li> <li> <p><code>/airbot_play/joint_states</code></p> <p>Topic type: <code>sensor_msgs::JointState</code>.</p> <p>Publish the current joint angles of the robotic arm. The order of the joint angles is consistent with the order of the joints in the URDF model (from the base to the end).</p> <p>An example of the published joint angles:</p> <p><pre><code># rostopic echo -n 1 /airbot_play/joint_states\nheader:\n  seq: 13838\n  stamp:\n    secs: 1713452918\n    nsecs: 548530541\n  frame_id: \"airbot_arm\"\nname:\n  - joint1\n  - joint2\n  - joint3\n  - joint4\n  - joint5\n  - joint6\nposition: [-0.273708701133728, 0.15468832850456238, -0.02841992862522602, -0.47474631667137146, 0.308041512966156, 0.49420157074928284]\nvelocity: [-0.004395604599267244, -0.004395604599267244, -0.004395604599267244, -0.007326007355004549, -0.007326007355004549, 0.007326007355004549]\neffort: [-0.03663003817200661, 18.732601165771484, 3.0549449920654297, 0.08547008782625198, -0.07570207864046097, 0.05616605654358864]\n---\n</code></pre> 3. <code>/airbot_play/gripper/position</code></p> <p>Topic type: <code>std_msgs::Float64</code>.</p> <p>Publish the current status of the gripper. The status is a normalized value between <code>0</code> and <code>1</code> where <code>0</code> means close, <code>1</code> means open.</p> <p>An example of the published gripper status:</p> <pre><code># rostopic echo -n 1 /airbot_play/gripper/position\ndata: 0.0\n---\n</code></pre> </li> </ol>"},{"location":"sdk/ROS1/#joystick-control","title":"Joystick Control","text":""},{"location":"sdk/ROS1/#overview","title":"Overview","text":"<p>AIRBOT Play robotic arm can be controlled by a LogiTech F710 controller through 2.4G adapter.</p>"},{"location":"sdk/ROS1/#structure","title":"Structure","text":"<p>The joy support builds on top of the ros-interface package. The nodes responsible for controlling via joystick are:</p> <ul> <li> <p><code>joy</code> - a ROS driver provided by ros package <code>ros-noetic-joy</code> for a generic Linux joystick. The node reads data from a joystick and publishes <code>sensor_msgs/Joy</code> messages to the <code>/joy</code> topic.</p> </li> <li> <p><code>joy_proxy</code> - responsible for reading in raw <code>sensor_msgs/Joy</code> messages from the <code>/joy</code> topic and converting them into <code>/joy_latched</code> and <code>/joy_trigger</code> topics (Topic type: sensor_msgs/Joy messages). The two topics are used to latch the joystick buttons edges.</p> </li> <li> <p><code>airbot_arm_ros</code> - responsible for reading in <code>/joy_latched</code> and <code>/joy_trigger</code> topics and sending joint and gripper commands to the robto through arm-control package.</p> </li> </ul>"},{"location":"sdk/ROS1/#usage_1","title":"Usage","text":"<p>Launch the control node after connecting the 2.4G receiver of the joystick:</p> <pre><code>roslaunch ros_interface airbot_arm.launch\n</code></pre> <p>Tip</p> <p>A red error message might appear in the screen saying <pre><code>Couldn't open joystick force feedback!\n</code></pre> This is normal and will not affect the joystick operation.</p> <p>To understand how the joystick buttons map to controlling the robot, look at the diagram and bullet points below.</p> <p></p> <ul> <li> <p><code>Left stick horizontal:</code> move forward / backward in the base frame</p> </li> <li> <p><code>Left stick vertical</code>: move left / right in the base frame</p> </li> <li> <p><code>Right stick vertical</code>: move upward / downward in the base frame</p> </li> <li> <p><code>LT</code> + <code>Left stick horizontal</code>: move forward / backward in the end frame</p> </li> <li> <p><code>LT</code> + <code>Left stick vertical</code>: move left / right in the end frame</p> </li> <li> <p><code>LT</code> + <code>Right stick vertical</code>: move upward / downward in the end frame</p> </li> <li> <p><code>Y</code>: Start gravity compensation. Use any position control commands to exit this mode</p> </li> <li> <p><code>A</code>: Start recording. Press again to stop recording</p> </li> <li> <p><code>B</code>: Start replaying recorded trajectory</p> </li> <li> <p><code>RT</code> + <code>Right stick vertical</code>: rotate pitch relative to end frame</p> </li> <li> <p><code>RT</code> + <code>Right stick horizontal</code>: rotate yaw relative to end frame</p> </li> <li> <p><code>RT</code> + <code>D-Pad left / right</code>: rotate roll relative to end frame</p> </li> </ul> <p>The Logitech gamepad (joystick) supports both XInput and DirectInput  interface modes. You can switch between these two modes by sliding a switch on the side of the gamepad. It\u2019s recommended that you leave the gamepad in XInput mode, which is marked \u201cX\u201d (1)  on the gamepad side. In XInput mode, the gamepad uses standard Windows XInput gamepad drivers. It is not necessary to install Logitech Gaming software unless you are using the gamepad in DirectInput mode.</p> <p></p>"},{"location":"sdk/aloha/","title":"AIRBOT Play \u00d7 ALOHA","text":""},{"location":"sdk/aloha/#introduction","title":"Introduction","text":"<p>This tutorial is about demonstration (single or double arm manipulation) for raw data collecting, data converting (convert raw data to hdf5 file used by the learning algorithms) and data replaying.</p> <p>Please ask the customer service for all available dependency packages and source codes files. We will gradually provide relevant download links in the future.</p> <p>Docker Notation</p> <p>If you want to install and use these packages in Docker, you should run your container with some necessary args, for example:</p> <p><pre><code>docker run -it --name airbot_play --network=host --privileged=true -v /lib/modules:/lib/modules,/tmp/.X11-unix:/tmp/.X11-unix -e DISPLAY=$DISPLAY ubuntu:20.04\n</code></pre> And you probably can not install the deb packages when they are in <code>/root</code>. In this case, you can move the packages and the terminal to <code>/tmp</code> first:</p> <pre><code>mv airbot_*.deb /tmp/ &amp;&amp; cd /tmp\n</code></pre> <p>In some Docker Containers, there is no <code>sudo</code> command, you can just remove it from the commands below.</p>"},{"location":"sdk/aloha/#environment-setup","title":"Environment Setup","text":"<p>Supported Operation Systems</p> <ul> <li>Ubuntu 20.04 LTS AMD64(x86_64)</li> <li>Ubuntu 20.04 LTS ARM64</li> </ul>"},{"location":"sdk/aloha/#data-collection-and-convertion-environment","title":"Data Collection and Convertion Environment","text":"<p>The core control package for data collection should be in the format of <code>airbot_play_&lt;version&gt;_&lt;arch&gt;.deb</code>. Install this package with the following command:</p> <pre><code>sudo apt update\nsudo apt install python3-pip python3 udev kmod iproute2 libcanberra-gtk-module libcanberra-gtk3-module -y\nsudo service udev restart &amp;&amp; udevadm control --reload\nsudo apt install ./airbot_play_*.deb -y\n</code></pre> <p>The functional package for data collection should be in the format of <code>airbot_aloha_&lt;version&gt;_&lt;arch&gt;.deb</code>. Install this package with the following command:</p> <pre><code>sudo apt install ./airbot_aloha_*.deb\n</code></pre>"},{"location":"sdk/aloha/#data-replay-environment","title":"Data Replay Environment","text":"<ul> <li> <p>Data Collection and Convertion Environment needs to be configured first.</p> </li> <li> <p>This configuration will install the AIRBOT Play Python API.</p> </li> </ul> <p>The source code file name should be in the format of <code>airbot_play_python_&lt;version&gt;.zip</code>. Run the following command to extract and build the project:</p> <pre><code>sudo apt install librosconsole-dev liburdf-dev libspdlog-dev libfmt-dev git -y\ncp airbot_play_python_2.7.zip airbot_play_python.zip\nunzip airbot_play_python.zip -q &amp;&amp; sudo rm -rf airbot_play_python.zip\ncd airbot_play_python/python\ngit clone --depth 1 https://github.com/pybind/pybind11.git\nmkdir build &amp;&amp; cd build\ncmake .. &amp;&amp; make -j32 &amp;&amp; cd ..\n</code></pre> <p>Note: If you manually download the pybind11 project, then you should extract and rename the folder to <code>pybind11</code> and replace the empty pybind11 folder in <code>airbot_play_python/python</code>.</p> <p>Finally, install the airbot python package via pip:</p> <pre><code>pip install . -i https://pypi.mirrors.ustc.edu.cn/simple/\n</code></pre>"},{"location":"sdk/aloha/#data-collection","title":"Data Collection","text":"<ul> <li> <p>Data Collection and Convertion Environment needs to be configured first.</p> </li> <li> <p>The task name should be reasonable, and it is recommended to include time in the name to distinguish the same task data collected at different times.</p> </li> </ul>"},{"location":"sdk/aloha/#starting-robotic-arms","title":"Starting Robotic Arms","text":"<ol> <li>Prepare all teaching arms and execution robotic arms.</li> <li>Connect the power sources of all robotic arms (order doesn't matter).</li> <li>First, connect the teaching arm via Type-C data cable (corresponding to CAN0), then connect the execution arm, too (corresponding to CAN1). For dual-arm operations, follow the above sequence for the left-side robotic arm first, then the right-side arm.</li> <li>Long-press the power button on each robotic arm to turn them on.</li> <li>Ensure that the robotic arms are at the zero pose; otherwise, perform a zero calibration.</li> </ol> <p>Note: Other devices connected to your computer may occupy the CAN interfaces, you may need to change the dufault can interfaces manually. Please refer to Explanation of Parameters.</p>"},{"location":"sdk/aloha/#connecting-cameras","title":"Connecting Cameras","text":"<p>Data collection typically requires multiple cameras, and the connection order can be as follows:</p> <ul> <li>Single-arm task sequence: Arm-mounted camera left eye -&gt; Arm-mounted camera right eye -&gt; Base-mounted camera</li> <li>Dual-arm task: Left arm camera -&gt; Right arm camera -&gt; Environment camera top -&gt; Environment camera bottom</li> </ul> <p>The above sequence is just a reference: the actual connection order depends on the number of cameras and their placement. Generally, prioritize connecting arm-mounted, left-side, and overhead cameras first.</p>"},{"location":"sdk/aloha/#starting-data-collection","title":"Starting Data Collection","text":"<p><pre><code>airbot_demonstrate \\\n    -c &lt;cam_device_0&gt; -c &lt;cam_device_1&gt; -c &lt;cam_device_2&gt; \\\n    -mts &lt;max_time_step&gt; \\\n    -tn &lt;task_name&gt; \\\n    -se &lt;start_episode_index&gt; \\\n    -f 15 \\\n    -sjp &lt;joint_pos_1&gt; &lt;joint_pos_2&gt; &lt;joint_pos_3&gt; &lt;joint_pos_4&gt; &lt;joint_pos_5&gt; &lt;joint_pos_6&gt; &lt;gripper_pos&gt;\n</code></pre> For dual-arm tasks, replace the command <code>airbot_demonstrate</code> with <code>airbot_demonstrate_dual</code> and change -sjp to -sjpl and -sjpr to specify the initial joint positions of left arm and right arm respectively (both defualt to 0 if not used).</p>"},{"location":"sdk/aloha/#explanation-of-parameters","title":"Explanation of Parameters","text":"<ul> <li><code>-c</code>: Device number of the USB cameras, the order of multiple device numbers (i.e., camera sequence) is specified by the specific task.<ul> <li>Typically, follow the connection order, where available camera device numbers are incremented by even numbers, such as 0, 2, 4...</li> <li>If your computer has a built-in regular camera, it occupies one device number, and externally connected camera device numbers start from 2 and increment by even numbers: 2, 4, 6... (if cameras were connected before the computer started, the device number of the built-in camera may not be 0; in rare cases, after connecting cameras post-startup, the built-in camera's device number may not be 0).</li> <li>If your computer has a built-in depth/structured light camera (like Windows Hello camera), the RGB camera and depth camera each occupy a device number, and externally connected camera device numbers start from 4 and increment by even numbers: 4, 6, 8...</li> </ul> </li> <li><code>-mts</code>: Specifies the maximum number of frames to be captured; specified by the specific task. When reaching the maximum time steps, the program will prompt.</li> <li><code>-tn</code>: Task name, specified by the specific task.<ul> <li>The collected data will be saved in the <code>demonstrations/(raw/)&lt;task_name&gt;</code> folder in the current directory.</li> </ul> </li> <li><code>-se</code>: Starting episode number for collection, default is 0.<ul> <li>After interruption, you can modify this value to continue collection without overwriting previous data.</li> <li>When data is mistakenly saved, specifying this episode number allows for re-collection to overwrite existing data.</li> <li>When collecting data multiple times after executing the command, the episode numbers of subsequent collections will increment from this base.</li> <li>Each set of data is saved in the <code>demonstrations/(raw/)&lt;task_name&gt;/&lt;episode_id&gt;</code> folder.</li> </ul> </li> <li><code>-sjp</code>: Initial positions of each joint and gripper before starting collection for each episode; defaults to 0 if not used. Specify values based on the actual situation of the specific task.</li> <li><code>-f</code>: Data collection frequency, default is 15Hz.</li> </ul> <p>And there are some other parameters for flexible usage:</p> <ul> <li><code>-m</code>: the can interface of of the teacher arm, default to can0.</li> <li><code>-n</code>: the can interface of of the follower arm, default to can1.</li> </ul>"},{"location":"sdk/aloha/#excution-example","title":"Excution Example","text":"<ul> <li>One teacher with one follower:     <pre><code>airbot_demonstrate -c 0 -mts 100 -tn test_task -sjp 0.0 0.0 0.0 0.0 0.0 0.0 0.0\n</code></pre></li> <li>Two teachers with two followers:     <pre><code>airbot_demonstrate_dual -c 0 -mts 100 -tn test_task -sjpl 0.0 0.0 0.0 0.0 0.0 0.0 0.0 -sjpr 0.0 0.0 0.0 0.0 0.0 0.0 0.0\n</code></pre></li> </ul>"},{"location":"sdk/aloha/#key-descriptions","title":"Key Descriptions","text":"<p>Do not press or hold keys continuously; otherwise, the key's behavior will repeat sequentially.</p> <p>After excuting the command above, the terminal will be cleaned and you can use keyboard to control. The key descriptions are as follows:</p> <ul> <li><code>g</code>: Toggle gravity compensation on/off.</li> <li><code>Spacebar</code>: Start/stop episode data recording.</li> <li><code>q</code>: Discard the current record.</li> <li><code>0</code>: Return the robotic arm to the initial position.</li> <li><code>p</code>: Print current robotic arm states information. If the information is not displayed properly, increase your terminal width.</li> </ul>"},{"location":"sdk/aloha/#operational-steps","title":"Operational Steps","text":"<ol> <li>Start the program, and the real-time windows of each camera will appear (if not all cameras start, try adjusting device numbers or checking camera connections; try connecting only one camera per docking station; some computers may support only 1-2 external cameras when USB ports share the same bus, consider changing the computer).</li> <li>Press <code>Spacebar</code> to start recording data and simultaneously, teleoperate the robotic arm to complete the task.</li> <li>After completing the task, wait to collect the specified number of frames (the number of frames used to complete the task should be as close as possible to the maximum collection frames):<ul> <li>If the teaching opration is not acceptable, press <code>q</code> to discard the current teaching record, then press <code>0</code> to control the robotic arm to return to the initial position.</li> <li>If it is acceptable, press <code>Spacebar</code> to save the current teaching record. After saving, the robotic arm will automatically return to the initial position.</li> </ul> </li> <li>(Optional) In the <code>demonstrations/(raw/)&lt;task_name&gt;</code> folder in the current directory, check the recorded episodes.<ul> <li>Each collected episode data includes: videos recorded by cameras (.avi), and a robotic arm status record file (.json).</li> </ul> </li> </ol> <p>Additional Notes:</p> <ol> <li> <p>Try to ensure that the completed task actions are completed just before reaching the maximum frame count, i.e., do not end the action too early.</p> </li> <li> <p>The robotic arm movement speed should not be too fast; otherwise, the collected information will be sparse, and the image quality will not be high.</p> </li> <li> <p>It is recommended to store the collected task data folder  in the same directory structure on a portable hard drive as a backup."},{"location":"sdk/aloha/#data-convertion","title":"Data Convertion","text":"<p>Data Collection and Convertion Environment needs to be configured first.</p> <p>In the same path where the data collection command was executed, run the following command to save the data in hdf5 format:</p> <pre><code>/usr/bin/python3 -m airbot_aloha.convert_episodes -rn 1 -cn 0 -tn test_task -se 0 -ee 0 -rd ./demonstrations\n</code></pre> <p>Parameter explanation:</p> <ul> <li><code>-cn</code>: Specify camera names. For example, if there are 2 cameras, then specify <code>-cn 0,1</code>.</li> <li><code>-tn</code>: Specify the task name, same as specified during data collection.</li> <li><code>-se</code>: Specify the starting episode number of the data.</li> <li><code>-ee</code>: Specify the ending episode number of the data.</li> <li><code>-rn</code>: For dual-arm tasks, specify <code>-rn</code> 2.</li> <li><code>-rd</code>: Path to your data directory.</li> </ul> <p>This command will search for the specified task data in the <code>demonstrations(/raw)</code> folder in the current directory and convert them to hdf5 files into the <code>demonstrations/hdf5</code> folder.</p> <p>Similarly, it is recommended to store the converted task data folder <code>&lt;task_name&gt;</code> in the same directory structure on a portable hard drive as a backup.</p>"},{"location":"sdk/aloha/#data-replay-optional","title":"Data Replay (Optional)","text":"<p>Data replay can be used to verify if there are issues with collected data, init states of the environment, etc. (requires prior setup of the Data Replay Environment).</p> <p>The data replay command and its parameters are as follows:</p> <pre><code>/usr/bin/python3 -m airbot_aloha.replay_episodes -rn 1 -tn test_task -ei 0 -ii -can 1 -cn 0\n</code></pre> <p>Parameter explanation:</p> <ul> <li><code>-tn</code>: Specify the task name.</li> <li><code>-ei</code>: Specify the ID corresponding to the HDF file.</li> <li><code>-can</code>: CAN ID of the follower arms. For dual-arm tasks, you can set <code>-can 1 3</code> if you followed the connection order in Starting-Robotic-Arms. Also, you can unplug all the Type-C wires first and only connect the follower arms, then set <code>-can 0 1</code>.</li> <li><code>-ii</code>: Do not replay camera data.</li> <li><code>-ia</code>: Do not replay action data.</li> <li><code>-rn</code>: For dual-arm tasks, specify <code>-rn</code> 2.</li> <li><code>-cn</code>: The name of the cameras data to be replayed. For example, if there are 2 cameras, then specify <code>-cn 0,1</code>.</li> </ul>"},{"location":"upgrade/airbot-play/","title":"AIRBOT Play Firmware Upgrade Guide","text":"<p>In this tutorial, we will show the detailed operations for upgrading the firmware of AIRBOT Play.</p> <p>After obtaining the SDK package, the upgrade of AIRBOT Play firmware consists of upgrading base interface board, motor controller firmware and end interface board firmware.</p>"},{"location":"upgrade/airbot-play/#sdk-package","title":"SDK Package","text":"<p>Please contact technical support to obtain the SDK package. After extracting the SDK package, the directory structure is as follows: <pre><code># tree 2.8.3/\n.\n\u251c\u2500\u2500 CHANGELOG\n\u251c\u2500\u2500 SHA1.txt\n\u251c\u2500\u2500 firmwares\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 BLDC_4_ChibiOS.bin                                   # Motor controller firmware\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 arm-interface-board-base.bin                         # Base interface board firmware \n\u2502\u00a0\u00a0 \u2514\u2500\u2500 end                                                  # End interface board firmware for different end effectors\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 arm-interface-board-end_desheng_servo.bin\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 arm-interface-board-end_jodell_2_fingers.bin\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 arm-interface-board-end_jodell_suction_cup.bin\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 arm-interface-board-end_yingshi_2_fingers.bin\n\u2514\u2500\u2500 packages\n    \u251c\u2500\u2500 airbot_aloha_2.8.3-291bbb4_amd64.deb                 # ALOHA example package, depends on the basic control library package\n    \u251c\u2500\u2500 airbot_play_2.8.3-a117c2fe_amd64.deb                 # Basic control library package, provides support for various interfaces\n    \u251c\u2500\u2500 airbot_tools_2.8.3-291bbb4_amd64.deb                 # Example tools package, depends on the basic control library package\n    \u251c\u2500\u2500 ros-noetic-ros-interface_2.8.3-0focal_amd64.deb      # ROS Interface package, depends on the basic control library package\n    \u2514\u2500\u2500 sdk-develop-python.zip\n</code></pre></p> <p>Each upgrade comes with update of both firmwares and packages. The usage of packages can be found here. The upgrade process only needs files under the <code>firmwares</code> directory.</p>"},{"location":"upgrade/airbot-play/#upgrading-base-interface-board","title":"Upgrading Base Interface Board","text":""},{"location":"upgrade/airbot-play/#preparing-environment-stm32cubeprogrammer","title":"Preparing environment: STM32CubeProgrammer","text":"<p>Download STM32CubeProgrammer version <code>2.15</code> from here:</p> <p>Version <code>2.15</code> is mandatory</p> <p>Versions higher than <code>2.15</code> have known issues which would causes HARDWARE DAMAGE of the interface board.</p> Verbose steps <p> click on <code>Select Version</code> choose version <code>2.15</code>, then click <code>Accept</code> and <code>Download as Guest</code> in sequence.</p> <p>Extract and install the downloaded package with the following command:</p> <pre><code>./SetupSTM32CubeProgrammer-2.15.0.linux\n</code></pre> <p>Store the installation path as <code>CUBE_INSTALL_PATH</code> environment variable: (replace <code>/path/to/installation</code> with the actual installation path) <pre><code>echo \"export CUBE_INSTALL_PATH=/path/to/installation\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre></p> Verbose steps <p>In the pop-up window, click <code>Next</code>, <code>Next</code> select <code>I accept the terms of the license agreements</code> then click <code>Next</code>  You can customize the installation path here. After selecting the path, click <code>Next</code>. If the path does not exist, a pop-up window will prompt that the target folder will be created. Click <code>OK</code>. Then, check <code>I have read and understood the ST Terms of Use</code> and keep clicking <code>Next</code> until the installation completes, then click <code>Done</code>.</p>"},{"location":"upgrade/airbot-play/#burn-firmware","title":"Burn Firmware","text":"<ol> <li> <p>Detach the power supply and USB cable from the base and wait for 20 seconds.</p> </li> <li> <p>Press DOWN the CONFIG button with a thin tool and then attach a USB Type-C cable to USB-2 port. Make sure power supply is NOT attached.</p> CONFIG button on the base <p></p> </li> <li> <p>Connect the other end of the USB Type-C cable to the computer with STM32CubeProgrammer installed.</p> </li> <li> <p>Suppose STM32CubeProgrammer is installed at <code>CUBE_INSTALL_PATH</code>. Launch STM32CubeProgrammer with</p> <pre><code>sudo ${CUBE_INSTALL_PATH}/bin/STM32CubeProgrammer\n</code></pre> Initial screen for STM32CubeProgrammer <p></p> </li> <li> <p>Select <code>USB</code> as the communication method, and click the refresh button. You should see <code>USB1</code> appears.</p> <p></p> USB1 not showing? <p>If the USB1 option is now showing, please make sure the CONFIG button is pressed DOWN and the USB cable is firmly attached to the base and the computer</p> </li> <li> <p>Click <code>Connect</code></p> </li> <li> <p>Select the firmware: <code>arm-interface-board-base.bin</code> inside the upgrade package:</p> <p></p> </li> <li> <p>After the firmware is loaded, click <code>Download</code> to burn firmware. It takes around 10 seconds, with a green line File download complete indicating successful burning.</p> <p></p> </li> <li> <p>Click <code>OK</code>. You can close STM32CubeProgrammer now.</p> </li> <li> <p>Detach the USB cable from the base and THEN use a thin tool to press UP the config button. The upgrade of the base interface board is complete now.</p> </li> </ol>"},{"location":"upgrade/airbot-play/#upgrading-motor-controller-firmware","title":"Upgrading Motor Controller Firmware","text":"<p>The 1st to 3rd motor controllers are connected to the base interface board. The firmware of the motor controller can be upgraded by running the following commands.</p> <p>Power Supply</p> <p>Make sure the power supply is attached to the AIRBOT Play when upgrading the firmware.</p> <p>Install <code>airbot_play</code> first</p> <p>Before upgrading the motor controller firmware, the <code>airbot_play</code> package should be installed first. See here.</p> <p>Suppose only one AIRBOT Play arm is connected to the computer (which makes the device name <code>can0</code>), run the following command to upgrade the firmware for the first motor:</p> <pre><code># Upgrade the firmware for the first motor of can0 device\npython -m airbot_play.iap_burn [&lt;path_to_firmware&gt;] -m can0 -i 1\n</code></pre> <p>Firmware Selection</p> <p>Please select the correct firmware for the end effector connected to the AIRBOT Play. The firmware for the motor controller is <code>BLDC_4_ChibiOS.bin</code> in the <code>firmwares</code> directory of the SDK package.</p> <p>Once the wrong firmware is burned, the whole AIRBOT Play would fail to work AT ALL. If the wrong firmware has already been burnt, please contact technical support for further assistance.</p> <p>Replace <code>&lt;path_to_firmware&gt;</code> with the path to the firmware file <code>BLDC_4_ChibiOS.bin</code> in the SDK package.</p> <p>Program Output</p> <pre><code># python iap.py BLDC_4_ChibiOS.bin -i 1 -m can0\nDevice name: vesc-motor-control\nDevice detected.\nVersion: 2.6.0\nRequest successful. Starting data transmission.\nTransmitting data... \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2578 100% 0:00:00\nEnd request successful. Data transmit finished.\nPlease wait for the program auto close and don't shutdown the power supply now.\nBurning firmware... \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% 0:00:00\nBurn finished.\nVersion: 2.7.0\nTime elapsed: 40.14004611968994 seconds\n</code></pre> <p>The version of the firmware will be displayed in the output. If the version is updated to the latest version, the upgrade is successful.</p> <p>Then, run the following commands to upgrade the firmware for the 2nd and 3rd motor:</p> <pre><code># Upgrade the firmware for the 2nd motor of can0 device\npython -m airbot_play.iap_burn [&lt;path_to_firmware&gt;] -m can0 -i 2\n# Upgrade the firmware for the 3rd motor of can0 device\npython -m airbot_play.iap_burn [&lt;path_to_firmware&gt;] -m can0 -i 3\n</code></pre> <p>Note</p> <p>If the end effector (AIRBOT Gripper or AIRBOT Demonstrator) is connected, the firmware of the controller can be updated by running the following command:</p> <pre><code>python -m airbot_play.iap_burn [&lt;path_to_firmware&gt;] -m can0 -i 7\n</code></pre>"},{"location":"upgrade/airbot-play/#upgrading-end-interface-board","title":"Upgrading End Interface Board","text":"<p>Firmware Selection</p> <p>Please select the correct firmware for the end effector connected to the AIRBOT Play. The firmware files are located in the <code>end</code> directory of the SDK package.</p> <p>Once the wrong firmware is burned, the whole AIRBOT Play would fail to work AT ALL. If the wrong firmware has already been burnt, please contact technical support for further assistance.</p> <p>Power Supply</p> <p>Make sure the power supply is attached to the AIRBOT Play when upgrading the firmware.</p> <p>Install <code>airbot_play</code> first</p> <p>Before upgrading the motor controller firmware, the <code>airbot_play</code> package should be installed first. See here.</p> <p>The end interface board firmware can be upgraded by running the following command:</p> <pre><code># Upgrade the firmware for the end interface board of can0 device\npython -m airbot_play.iap_burn [&lt;path_to_firmware&gt;] -m can0 -i 8\n</code></pre> <p>Replace <code>&lt;path_to_firmware&gt;</code> with the path to the firmware file <code>arm-interface-board-end_*.bin</code> in the SDK package. Any one of the four end interface board firmware can be selected.</p>"}]}