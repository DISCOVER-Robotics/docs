<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AIRBOT Play Controller: arm::Robot Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AIRBOT Play Controller
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>arm</b></li><li class="navelem"><a class="el" href="classarm_1_1Robot.html">Robot</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classarm_1_1Robot-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">arm::Robot Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classarm_1_1Robot.html" title="The Robot class for controlling the robot arm.">Robot</a> class for controlling the robot arm.  
 <a href="classarm_1_1Robot.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="command__base_8hpp_source.html">command_base.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a01d7db791f01b395ee3886959fc60a64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a01d7db791f01b395ee3886959fc60a64">Robot</a> (std::string urdf_path, std::string can_interface, std::string direction=&quot;down&quot;, double vel=M_PI, std::string end_mode=&quot;teacher&quot;, bool constraint=false, bool ignore_status_check=false, std::string forearm_type=&quot;DM&quot;, bool stay_init=false, bool ignore_limit=false)</td></tr>
<tr class="memdesc:a01d7db791f01b395ee3886959fc60a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classarm_1_1Robot.html" title="The Robot class for controlling the robot arm.">Robot</a> object.  <a href="classarm_1_1Robot.html#a01d7db791f01b395ee3886959fc60a64">More...</a><br /></td></tr>
<tr class="separator:a01d7db791f01b395ee3886959fc60a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ea78e90e871099d839e7a82b11c7a0"><td class="memItemLeft" align="right" valign="top"><a id="a61ea78e90e871099d839e7a82b11c7a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a61ea78e90e871099d839e7a82b11c7a0">set_zero</a> ()</td></tr>
<tr class="memdesc:a61ea78e90e871099d839e7a82b11c7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current position of the motors as the zero position This function will set the current position of the motors as the zero position. This function should be <b>NOT</b> be called while the robot is moving. <br /></td></tr>
<tr class="separator:a61ea78e90e871099d839e7a82b11c7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec687a3a73cd5bafe1564d01adaf93a"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a6ec687a3a73cd5bafe1564d01adaf93a">get_target_pose</a> () const</td></tr>
<tr class="memdesc:a6ec687a3a73cd5bafe1564d01adaf93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target end pose in Cartesian space.  <a href="classarm_1_1Robot.html#a6ec687a3a73cd5bafe1564d01adaf93a">More...</a><br /></td></tr>
<tr class="separator:a6ec687a3a73cd5bafe1564d01adaf93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896798269a138c327588d1e3208e04f8"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a896798269a138c327588d1e3208e04f8">get_plan_target_pose</a> () const</td></tr>
<tr class="memdesc:a896798269a138c327588d1e3208e04f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the planning target end pose in Cartesian space.  <a href="classarm_1_1Robot.html#a896798269a138c327588d1e3208e04f8">More...</a><br /></td></tr>
<tr class="separator:a896798269a138c327588d1e3208e04f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13044f0b9a63b331d552fca0bc177897"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a13044f0b9a63b331d552fca0bc177897">get_target_joint_q</a> () const</td></tr>
<tr class="memdesc:a13044f0b9a63b331d552fca0bc177897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target joint positions in joint space.  <a href="classarm_1_1Robot.html#a13044f0b9a63b331d552fca0bc177897">More...</a><br /></td></tr>
<tr class="separator:a13044f0b9a63b331d552fca0bc177897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b295b935da82c0b1684b34689e9072"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a01b295b935da82c0b1684b34689e9072">get_plan_target_joint_q</a> () const</td></tr>
<tr class="memdesc:a01b295b935da82c0b1684b34689e9072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the planning target joint positions in joint space.  <a href="classarm_1_1Robot.html#a01b295b935da82c0b1684b34689e9072">More...</a><br /></td></tr>
<tr class="separator:a01b295b935da82c0b1684b34689e9072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714a388fddfe380385f0d89530ea9f1d"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a714a388fddfe380385f0d89530ea9f1d">get_target_joint_v</a> () const</td></tr>
<tr class="memdesc:a714a388fddfe380385f0d89530ea9f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target joint velocities in joint space.  <a href="classarm_1_1Robot.html#a714a388fddfe380385f0d89530ea9f1d">More...</a><br /></td></tr>
<tr class="separator:a714a388fddfe380385f0d89530ea9f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f45efa7f178811dda4f45b3e491514b"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a4f45efa7f178811dda4f45b3e491514b">get_target_translation</a> () const</td></tr>
<tr class="memdesc:a4f45efa7f178811dda4f45b3e491514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the translation part of the target end pose.  <a href="classarm_1_1Robot.html#a4f45efa7f178811dda4f45b3e491514b">More...</a><br /></td></tr>
<tr class="separator:a4f45efa7f178811dda4f45b3e491514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4791544f6e44ab3a5778153d77109d"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#aae4791544f6e44ab3a5778153d77109d">get_target_rotation</a> () const</td></tr>
<tr class="memdesc:aae4791544f6e44ab3a5778153d77109d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rotation part of the target end pose.  <a href="classarm_1_1Robot.html#aae4791544f6e44ab3a5778153d77109d">More...</a><br /></td></tr>
<tr class="separator:aae4791544f6e44ab3a5778153d77109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa17ecac7a5ab6ab9a93a5855f70b5da"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#aaa17ecac7a5ab6ab9a93a5855f70b5da">get_current_pose</a> () const</td></tr>
<tr class="memdesc:aaa17ecac7a5ab6ab9a93a5855f70b5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current end pose in Cartesian space.  <a href="classarm_1_1Robot.html#aaa17ecac7a5ab6ab9a93a5855f70b5da">More...</a><br /></td></tr>
<tr class="separator:aaa17ecac7a5ab6ab9a93a5855f70b5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a981a415b06dccf1ee0a6fe943d72d6"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a0a981a415b06dccf1ee0a6fe943d72d6">get_current_joint_q</a> () const</td></tr>
<tr class="memdesc:a0a981a415b06dccf1ee0a6fe943d72d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current joint positions in joint space.  <a href="classarm_1_1Robot.html#a0a981a415b06dccf1ee0a6fe943d72d6">More...</a><br /></td></tr>
<tr class="separator:a0a981a415b06dccf1ee0a6fe943d72d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa2cbcdf6524e006ae69525faf1cfc"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a72aa2cbcdf6524e006ae69525faf1cfc">get_current_joint_v</a> () const</td></tr>
<tr class="memdesc:a72aa2cbcdf6524e006ae69525faf1cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current joint velocities in joint space.  <a href="classarm_1_1Robot.html#a72aa2cbcdf6524e006ae69525faf1cfc">More...</a><br /></td></tr>
<tr class="separator:a72aa2cbcdf6524e006ae69525faf1cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a9094cbac0aeb41faa99d6d0514120"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#aa9a9094cbac0aeb41faa99d6d0514120">get_current_joint_t</a> () const</td></tr>
<tr class="memdesc:aa9a9094cbac0aeb41faa99d6d0514120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current joint torques in joint space.  <a href="classarm_1_1Robot.html#aa9a9094cbac0aeb41faa99d6d0514120">More...</a><br /></td></tr>
<tr class="separator:aa9a9094cbac0aeb41faa99d6d0514120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9553b274fcb47a68ce193821c3187dc2"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a9553b274fcb47a68ce193821c3187dc2">get_current_translation</a> () const</td></tr>
<tr class="memdesc:a9553b274fcb47a68ce193821c3187dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current translation part of the end pose.  <a href="classarm_1_1Robot.html#a9553b274fcb47a68ce193821c3187dc2">More...</a><br /></td></tr>
<tr class="separator:a9553b274fcb47a68ce193821c3187dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb63c850e1ea9e5db3b7fef1ad35863"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a4bb63c850e1ea9e5db3b7fef1ad35863">get_current_rotation</a> () const</td></tr>
<tr class="memdesc:a4bb63c850e1ea9e5db3b7fef1ad35863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current rotation part of the end pose.  <a href="classarm_1_1Robot.html#a4bb63c850e1ea9e5db3b7fef1ad35863">More...</a><br /></td></tr>
<tr class="separator:a4bb63c850e1ea9e5db3b7fef1ad35863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2866d37ab066f0ebd2e9cae173caacbe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a2866d37ab066f0ebd2e9cae173caacbe">get_current_end</a> () const</td></tr>
<tr class="memdesc:a2866d37ab066f0ebd2e9cae173caacbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current end effector position.  <a href="classarm_1_1Robot.html#a2866d37ab066f0ebd2e9cae173caacbe">More...</a><br /></td></tr>
<tr class="separator:a2866d37ab066f0ebd2e9cae173caacbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49003282ec9bed89926d39eaff9bf821"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a49003282ec9bed89926d39eaff9bf821">get_sn</a> () const</td></tr>
<tr class="memdesc:a49003282ec9bed89926d39eaff9bf821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SN code of the robot arm.  <a href="classarm_1_1Robot.html#a49003282ec9bed89926d39eaff9bf821">More...</a><br /></td></tr>
<tr class="separator:a49003282ec9bed89926d39eaff9bf821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0bec26dabf7c103cc7e6c0ff19684d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#abd0bec26dabf7c103cc7e6c0ff19684d">set_target_pose</a> (const vector&lt; vector&lt; double &gt;&gt; &amp;target_pose, bool use_planning=true, double time=DEFAULT_TIME)</td></tr>
<tr class="memdesc:abd0bec26dabf7c103cc7e6c0ff19684d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target end pose of the robot arm in Cartesian space.  <a href="classarm_1_1Robot.html#abd0bec26dabf7c103cc7e6c0ff19684d">More...</a><br /></td></tr>
<tr class="separator:abd0bec26dabf7c103cc7e6c0ff19684d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05533609f6ebe1279fc1734ad383ac5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ae05533609f6ebe1279fc1734ad383ac5">set_target_pose</a> (const vector&lt; double &gt; &amp;target_translation, const vector&lt; double &gt; &amp;target_rotation, bool use_planning=true, double time=DEFAULT_TIME)</td></tr>
<tr class="memdesc:ae05533609f6ebe1279fc1734ad383ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target end pose of the robot arm in Cartesian space.  <a href="classarm_1_1Robot.html#ae05533609f6ebe1279fc1734ad383ac5">More...</a><br /></td></tr>
<tr class="separator:ae05533609f6ebe1279fc1734ad383ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d85c1a88bf5d691bee5de3199c931b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#af4d85c1a88bf5d691bee5de3199c931b">set_target_translation</a> (const vector&lt; double &gt; &amp;target_translation, bool use_planning=true, double time=DEFAULT_TIME)</td></tr>
<tr class="memdesc:af4d85c1a88bf5d691bee5de3199c931b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target translation of the robot arm in Cartesian space.  <a href="classarm_1_1Robot.html#af4d85c1a88bf5d691bee5de3199c931b">More...</a><br /></td></tr>
<tr class="separator:af4d85c1a88bf5d691bee5de3199c931b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3478cb578e4722f0d32ca07e13cb384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ad3478cb578e4722f0d32ca07e13cb384">add_target_translation</a> (const vector&lt; double &gt; &amp;target_d_translation, bool use_planning=true, double time=DEFAULT_TIME)</td></tr>
<tr class="memdesc:ad3478cb578e4722f0d32ca07e13cb384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target relative translation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative translation to the current planning target.  <a href="classarm_1_1Robot.html#ad3478cb578e4722f0d32ca07e13cb384">More...</a><br /></td></tr>
<tr class="separator:ad3478cb578e4722f0d32ca07e13cb384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d508d33cc5e4c0092d0714219702e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ab8d508d33cc5e4c0092d0714219702e5">add_target_relative_translation</a> (const vector&lt; double &gt; &amp;target_d_translation, bool use_planning=true, double time=DEFAULT_TIME)</td></tr>
<tr class="memdesc:ab8d508d33cc5e4c0092d0714219702e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target relative translation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative translation to the current planning target. The addition is performed in <b>the base frame</b>.  <a href="classarm_1_1Robot.html#ab8d508d33cc5e4c0092d0714219702e5">More...</a><br /></td></tr>
<tr class="separator:ab8d508d33cc5e4c0092d0714219702e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82866fabc682085a66f148048eea4bf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a82866fabc682085a66f148048eea4bf3">add_target_relative_rotation</a> (const vector&lt; double &gt; &amp;target_d_rotation, bool use_planning=true, double time=DEFAULT_TIME)</td></tr>
<tr class="memdesc:a82866fabc682085a66f148048eea4bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target rotation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative rotation to the current planning target. The addition is performed in <b>the base frame</b>.  <a href="classarm_1_1Robot.html#a82866fabc682085a66f148048eea4bf3">More...</a><br /></td></tr>
<tr class="separator:a82866fabc682085a66f148048eea4bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1045902e6317812faeee539584a8cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a5a1045902e6317812faeee539584a8cc">set_target_rotation</a> (const vector&lt; double &gt; &amp;target_rotation, bool use_planning=true, double time=DEFAULT_TIME)</td></tr>
<tr class="memdesc:a5a1045902e6317812faeee539584a8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target rotation of the robot arm in Cartesian space.  <a href="classarm_1_1Robot.html#a5a1045902e6317812faeee539584a8cc">More...</a><br /></td></tr>
<tr class="separator:a5a1045902e6317812faeee539584a8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cbda1eeb5696f54e236342b5dd382c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a64cbda1eeb5696f54e236342b5dd382c">set_target_vel</a> (const vector&lt; vector&lt; double &gt;&gt; &amp;target_vel)</td></tr>
<tr class="memdesc:a64cbda1eeb5696f54e236342b5dd382c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Velocity control method. Set the target end velocities of the robot arm in Cartesian space.  <a href="classarm_1_1Robot.html#a64cbda1eeb5696f54e236342b5dd382c">More...</a><br /></td></tr>
<tr class="separator:a64cbda1eeb5696f54e236342b5dd382c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00fd5be719eeff43c37e6a726daa574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#aa00fd5be719eeff43c37e6a726daa574">set_target_joint_q</a> (const vector&lt; double &gt; &amp;target_joint_q, bool use_planning=true, double time=DEFAULT_TIME)</td></tr>
<tr class="memdesc:aa00fd5be719eeff43c37e6a726daa574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target joint positions of the robot arm in joint space.  <a href="classarm_1_1Robot.html#aa00fd5be719eeff43c37e6a726daa574">More...</a><br /></td></tr>
<tr class="separator:aa00fd5be719eeff43c37e6a726daa574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052b319a1fd43a848d958b1fb5bd7272"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a052b319a1fd43a848d958b1fb5bd7272">add_target_joint_q</a> (const vector&lt; double &gt; &amp;target_d_joint_q, bool use_planning=true, double time=DEFAULT_TIME)</td></tr>
<tr class="memdesc:a052b319a1fd43a848d958b1fb5bd7272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position control method. Set the target joint positions of the robot arm in joint space. The robot will move to the target pose by adding the relative joint positions to the current planning target joint position targets.  <a href="classarm_1_1Robot.html#a052b319a1fd43a848d958b1fb5bd7272">More...</a><br /></td></tr>
<tr class="separator:a052b319a1fd43a848d958b1fb5bd7272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cc3427b836f7cf2a72da21b2d9d02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ab6cc3427b836f7cf2a72da21b2d9d02e">set_target_joint_v</a> (const vector&lt; double &gt; &amp;target_joint_v)</td></tr>
<tr class="memdesc:ab6cc3427b836f7cf2a72da21b2d9d02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Velocity control method. Set the target joint velocities of the robot arm in joint space.  <a href="classarm_1_1Robot.html#ab6cc3427b836f7cf2a72da21b2d9d02e">More...</a><br /></td></tr>
<tr class="separator:ab6cc3427b836f7cf2a72da21b2d9d02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347d7da27770aca589cf88e880b97548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a347d7da27770aca589cf88e880b97548">add_target_joint_v</a> (const vector&lt; double &gt; &amp;target_d_joint_v)</td></tr>
<tr class="memdesc:a347d7da27770aca589cf88e880b97548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Velocity control method. Set the target joint velocities of the robot arm in joint space. The robot will accelerate / decelerate to target joint velocities by adding the relative joint velocities to the current joint velocity targets.  <a href="classarm_1_1Robot.html#a347d7da27770aca589cf88e880b97548">More...</a><br /></td></tr>
<tr class="separator:a347d7da27770aca589cf88e880b97548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcd76724848d66e7a1df6564a1569bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a2dcd76724848d66e7a1df6564a1569bc">set_target_joint_t</a> (const vector&lt; double &gt; &amp;target_joint_t)</td></tr>
<tr class="memdesc:a2dcd76724848d66e7a1df6564a1569bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Torque control method. Set the target joint torques of the robot arm in joint space.  <a href="classarm_1_1Robot.html#a2dcd76724848d66e7a1df6564a1569bc">More...</a><br /></td></tr>
<tr class="separator:a2dcd76724848d66e7a1df6564a1569bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65f7274a04350c64d7d11c1f30e3a1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ad65f7274a04350c64d7d11c1f30e3a1b">set_target_end</a> (const double &amp;end_pose)</td></tr>
<tr class="memdesc:ad65f7274a04350c64d7d11c1f30e3a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target end position of the robot arm. The end position is a normalized value between 0 and 1, where 0 denotes that the end effector is closed and 1 denotes that the end effector is open.  <a href="classarm_1_1Robot.html#ad65f7274a04350c64d7d11c1f30e3a1b">More...</a><br /></td></tr>
<tr class="separator:ad65f7274a04350c64d7d11c1f30e3a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cd197b5f1d540bc12c23c8a6bc62ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ad4cd197b5f1d540bc12c23c8a6bc62ff">record_start</a> (const std::string &amp;record_type=&quot;q&quot;)</td></tr>
<tr class="memdesc:ad4cd197b5f1d540bc12c23c8a6bc62ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start recording the trajectory of the robot arm.  <a href="classarm_1_1Robot.html#ad4cd197b5f1d540bc12c23c8a6bc62ff">More...</a><br /></td></tr>
<tr class="separator:ad4cd197b5f1d540bc12c23c8a6bc62ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1021aaecd0ade8d8bbf652a12327af02"><td class="memItemLeft" align="right" valign="top"><a id="a1021aaecd0ade8d8bbf652a12327af02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a1021aaecd0ade8d8bbf652a12327af02">record_stop</a> ()</td></tr>
<tr class="memdesc:a1021aaecd0ade8d8bbf652a12327af02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop recording the trajectory of the robot arm. <br /></td></tr>
<tr class="separator:a1021aaecd0ade8d8bbf652a12327af02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5083a372e9e789e39c8c30afe86372"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a1d5083a372e9e789e39c8c30afe86372">record_replay</a> ()</td></tr>
<tr class="memdesc:a1d5083a372e9e789e39c8c30afe86372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replay the recorded / loaded trajectory of the robot arm.  <a href="classarm_1_1Robot.html#a1d5083a372e9e789e39c8c30afe86372">More...</a><br /></td></tr>
<tr class="separator:a1d5083a372e9e789e39c8c30afe86372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c933ad91fc4dcc39c36f2109108d6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a54c933ad91fc4dcc39c36f2109108d6a">record_save</a> (const std::string &amp;filepath)</td></tr>
<tr class="memdesc:a54c933ad91fc4dcc39c36f2109108d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the recorded trajectory to a file.  <a href="classarm_1_1Robot.html#a54c933ad91fc4dcc39c36f2109108d6a">More...</a><br /></td></tr>
<tr class="separator:a54c933ad91fc4dcc39c36f2109108d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80009633b8ad383d1b8f45de68d49548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a80009633b8ad383d1b8f45de68d49548">record_load</a> (const std::string &amp;filepath)</td></tr>
<tr class="memdesc:a80009633b8ad383d1b8f45de68d49548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the recorded trajectory from a file.  <a href="classarm_1_1Robot.html#a80009633b8ad383d1b8f45de68d49548">More...</a><br /></td></tr>
<tr class="separator:a80009633b8ad383d1b8f45de68d49548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e029afff87e1533bd2e21eba6a95d98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a2e029afff87e1533bd2e21eba6a95d98">valid_target_pose</a> (const vector&lt; vector&lt; double &gt;&gt; &amp;target_pose) const</td></tr>
<tr class="memdesc:a2e029afff87e1533bd2e21eba6a95d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given target pose is valid for AIRBOT Play.  <a href="classarm_1_1Robot.html#a2e029afff87e1533bd2e21eba6a95d98">More...</a><br /></td></tr>
<tr class="separator:a2e029afff87e1533bd2e21eba6a95d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17762deeee58a73ee055586ec1dcff83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a17762deeee58a73ee055586ec1dcff83">valid_joint_q</a> (const vector&lt; double &gt; &amp;joint_q) const</td></tr>
<tr class="memdesc:a17762deeee58a73ee055586ec1dcff83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given target joint positions are valid for AIRBOT Play.  <a href="classarm_1_1Robot.html#a17762deeee58a73ee055586ec1dcff83">More...</a><br /></td></tr>
<tr class="separator:a17762deeee58a73ee055586ec1dcff83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72d4095fde785566b58d56e0079e88c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#af72d4095fde785566b58d56e0079e88c">reached_target_pose</a> (double threshold=0.01) const</td></tr>
<tr class="memdesc:af72d4095fde785566b58d56e0079e88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the robot has reached the target pose.  <a href="classarm_1_1Robot.html#af72d4095fde785566b58d56e0079e88c">More...</a><br /></td></tr>
<tr class="separator:af72d4095fde785566b58d56e0079e88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0fa253d03b7eef6d236dba1c79ed33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a3e0fa253d03b7eef6d236dba1c79ed33">reached_target_joint_q</a> (double threshold=0.01) const</td></tr>
<tr class="memdesc:a3e0fa253d03b7eef6d236dba1c79ed33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the robot has reached the target joint positions.  <a href="classarm_1_1Robot.html#a3e0fa253d03b7eef6d236dba1c79ed33">More...</a><br /></td></tr>
<tr class="separator:a3e0fa253d03b7eef6d236dba1c79ed33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac427a2060a70f66f36a438aba0de0517"><td class="memItemLeft" align="right" valign="top"><a id="ac427a2060a70f66f36a438aba0de0517"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#ac427a2060a70f66f36a438aba0de0517">gravity_compensation</a> ()</td></tr>
<tr class="memdesc:ac427a2060a70f66f36a438aba0de0517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter the gravity compensation mode. <br /></td></tr>
<tr class="separator:ac427a2060a70f66f36a438aba0de0517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11179a90516964331c00cc1678acc1ac"><td class="memItemLeft" align="right" valign="top"><a id="a11179a90516964331c00cc1678acc1ac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#a11179a90516964331c00cc1678acc1ac">stop_gravity_compensation</a> ()</td></tr>
<tr class="memdesc:a11179a90516964331c00cc1678acc1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the gravity compensation mode. <br /></td></tr>
<tr class="separator:a11179a90516964331c00cc1678acc1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:addd37390481bde902f265a0b6a726258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarm_1_1Robot.html#addd37390481bde902f265a0b6a726258">update_motor_</a> (bool send=true)</td></tr>
<tr class="separator:addd37390481bde902f265a0b6a726258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classarm_1_1Robot.html" title="The Robot class for controlling the robot arm.">Robot</a> class for controlling the robot arm. </p>
<ol type="1">
<li>plug-to-play</li>
<li>control mode and light effect</li>
<li>Demonstrate Mode / Replay Mode / Online Mode </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a01d7db791f01b395ee3886959fc60a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d7db791f01b395ee3886959fc60a64">&#9670;&nbsp;</a></span>Robot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arm::Robot::Robot </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>urdf_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>can_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>direction</em> = <code>&quot;down&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vel</em> = <code>M_PI</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>end_mode</em> = <code>&quot;teacher&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constraint</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_status_check</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>forearm_type</em> = <code>&quot;DM&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stay_init</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_limit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classarm_1_1Robot.html" title="The Robot class for controlling the robot arm.">Robot</a> object. </p>
<p>Once created, the instance will perform the following actions:</p>
<ol type="1">
<li>initialize forward and inverse kinematics solvers</li>
<li>initialize text-based loggers; logs will be saved in the <code>logs</code> directory</li>
<li>initialize and check the status of the base interface board</li>
<li>initialize and check the status of the motors, from the base to the end</li>
<li>initialize and check the status of the end interface board</li>
<li>update motor status</li>
<li>start the following threads:<ul>
<li>thread_sync_pose_: map joints to end pose</li>
<li>thread_update_motor_: send CAN messages to motors</li>
<li>thread_plan_: perform planning</li>
<li>thread_log_: start pushing robot status to Kibana</li>
<li>thread_snap_: start listening to the snap signals. will be removed in the future</li>
</ul>
</li>
<li>unlock the motors</li>
</ol>
<p>Typically, the instance should be created once and used throughout the program. Also, it is the user's responsibility to ensure that <b>ONLY ONE</b> instance is controlling the robot at a time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">urdf_path</td><td>the path to valid AIRBOT Play URDF File. By default, when installed via apt package, two valid urdf files are installed:<ul>
<li>AIRBOT Play with no end effector: <code>/usr/local/share/airbot_play/airbot_play_v2_1/urdf/airbot_play_v2_1.urdf</code></li>
<li>AIRBOT Play with AIRBOT Play demonstrator: <code>/usr/local/share/airbot_play/airbot_play_v2_1/urdf/airbot_play_v2_1_with_gripper.urdf</code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">can_interface</td><td>the interface recognized by the system. Usually in the form like <code>can0</code>, <code>can1</code>, etc. The currently available interfaces can be found by <code>ip link</code> command, given that <code>iproute2</code> package is installed on Debian-based systems </td></tr>
    <tr><td class="paramname">direction</td><td>the direction of the gravity. If AIRBOT Play is installed on a vertical surface, this option should be altered. Available options: "down", "left", "right" </td></tr>
    <tr><td class="paramname">vel</td><td>the maximum velocity of joints in Online / Replay mode. </td></tr>
    <tr><td class="paramname">end_mode</td><td>the end effector installed at the end. Available options:<ul>
<li><code>none</code>: no end effector is installed</li>
<li><code>gripper</code>: AIRBOT Gripper is installed</li>
<li><code>newteacher</code>: AIRBOT Demonstrator is installed </li>
</ul>
</td></tr>
    <tr><td class="paramname">constraint</td><td>whether or not AIRBOT Play stop moving once outside the joint limits </td></tr>
    <tr><td class="paramname">ignore_status_check</td><td>whether or not AIRBOT Play ignore the status check. This option is DEPRECATED, as it will be removed in the future </td></tr>
    <tr><td class="paramname">forearm_tpe</td><td>the type of the forearm. Available options:<ul>
<li><code>DM</code>: Damiao motors are installed</li>
<li><code>OD</code>: Self-designed motors are installed </li>
</ul>
</td></tr>
    <tr><td class="paramname">stay_init</td><td>whether or not AIRBOT Play stay in the initial position. If <code>false</code>, AIRBOT Play will move to the zero position once initialized. This option is DEPRECATED, as it will be removed in the future </td></tr>
    <tr><td class="paramname">ignore_limit</td><td>whether or not AIRBOT Play ignore the joint limits. This option is DEPRECATED, as it will be removed in the future </td></tr>
  </table>
  </dd>
</dl>
<p>Temporarily disable end motor status check before motor type auto-discovery is implemented</p>
<p>Since v2.3.0 (firmware version v12), the motor driver will automatically release brake on receiving control commands (e.g. MotorPosCmd, MotorSpdCmd, MotorMitCmd), avoiding overheat of the manual unlock of the brake. So repeatedly unlock the brake is not necessary.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a052b319a1fd43a848d958b1fb5bd7272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052b319a1fd43a848d958b1fb5bd7272">&#9670;&nbsp;</a></span>add_target_joint_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::add_target_joint_q </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_d_joint_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>DEFAULT_TIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target joint positions of the robot arm in joint space. The robot will move to the target pose by adding the relative joint positions to the current planning target joint position targets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_d_joint_q</td><td>the target relative joint positions in radians. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">time</td><td>the time scale to reach the target pose. If planning is disabled, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a347d7da27770aca589cf88e880b97548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347d7da27770aca589cf88e880b97548">&#9670;&nbsp;</a></span>add_target_joint_v()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::add_target_joint_v </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_d_joint_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Velocity control method. Set the target joint velocities of the robot arm in joint space. The robot will accelerate / decelerate to target joint velocities by adding the relative joint velocities to the current joint velocity targets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_joint_v</td><td>the target joint velocities in radians per second. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82866fabc682085a66f148048eea4bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82866fabc682085a66f148048eea4bf3">&#9670;&nbsp;</a></span>add_target_relative_rotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::add_target_relative_rotation </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_d_rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>DEFAULT_TIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target rotation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative rotation to the current planning target. The addition is performed in <b>the base frame</b>. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_d_rotation</td><td>the target relative rotation in quaternion format <code>( rx, ry, rz, rw )</code>. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">time</td><td>the time scale to reach the target pose. If planning is disabled, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8d508d33cc5e4c0092d0714219702e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d508d33cc5e4c0092d0714219702e5">&#9670;&nbsp;</a></span>add_target_relative_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::add_target_relative_translation </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_d_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>DEFAULT_TIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target relative translation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative translation to the current planning target. The addition is performed in <b>the base frame</b>. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_d_translation</td><td>the target relative translation in quaternion format <code>( rx, ry, rz, rw )</code>. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">time</td><td>the time scale to reach the target pose. If planning is disabled, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3478cb578e4722f0d32ca07e13cb384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3478cb578e4722f0d32ca07e13cb384">&#9670;&nbsp;</a></span>add_target_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::add_target_translation </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_d_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>DEFAULT_TIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target relative translation of the robot arm in Cartesian space. The robot will move to the target pose by adding the relative translation to the current planning target. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_d_translation</td><td>the target relative translation in meters. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">time</td><td>the time scale to reach the target pose. If planning is disabled, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2866d37ab066f0ebd2e9cae173caacbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2866d37ab066f0ebd2e9cae173caacbe">&#9670;&nbsp;</a></span>get_current_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double arm::Robot::get_current_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current end effector position. </p>
<p>The end effector position is a normalized value between 0 and 1, where 0 denotes that the end effector is closed and 1 denotes that the end effector is open.</p>
<dl class="section return"><dt>Returns</dt><dd>double: current end position in meters. </dd></dl>

</div>
</div>
<a id="a0a981a415b06dccf1ee0a6fe943d72d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a981a415b06dccf1ee0a6fe943d72d6">&#9670;&nbsp;</a></span>get_current_joint_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; arm::Robot::get_current_joint_q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current joint positions in joint space. </p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt;: current joint positions in radians. </dd></dl>

</div>
</div>
<a id="aa9a9094cbac0aeb41faa99d6d0514120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a9094cbac0aeb41faa99d6d0514120">&#9670;&nbsp;</a></span>get_current_joint_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; arm::Robot::get_current_joint_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current joint torques in joint space. </p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt;: current joint torques in Newton meters. </dd></dl>

</div>
</div>
<a id="a72aa2cbcdf6524e006ae69525faf1cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa2cbcdf6524e006ae69525faf1cfc">&#9670;&nbsp;</a></span>get_current_joint_v()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; arm::Robot::get_current_joint_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current joint velocities in joint space. </p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt;: current joint velocities in radians per second. </dd></dl>

</div>
</div>
<a id="aaa17ecac7a5ab6ab9a93a5855f70b5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa17ecac7a5ab6ab9a93a5855f70b5da">&#9670;&nbsp;</a></span>get_current_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; double &gt; &gt; arm::Robot::get_current_pose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current end pose in Cartesian space. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;vector&lt;double&gt;&gt;: current end pose consisting of translation and quaternion rotation in <code>(( x, y, z ), ( rx, ry, rz, rw ))</code> format. </dd></dl>

</div>
</div>
<a id="a4bb63c850e1ea9e5db3b7fef1ad35863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb63c850e1ea9e5db3b7fef1ad35863">&#9670;&nbsp;</a></span>get_current_rotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; arm::Robot::get_current_rotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current rotation part of the end pose. </p>
<p>The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector. The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt;: current rotation in quaternion format <code>( rx, ry, rz, rw )</code>. </dd></dl>

</div>
</div>
<a id="a9553b274fcb47a68ce193821c3187dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9553b274fcb47a68ce193821c3187dc2">&#9670;&nbsp;</a></span>get_current_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; arm::Robot::get_current_translation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current translation part of the end pose. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt;: current translation in meters. </dd></dl>

</div>
</div>
<a id="a01b295b935da82c0b1684b34689e9072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b295b935da82c0b1684b34689e9072">&#9670;&nbsp;</a></span>get_plan_target_joint_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; arm::Robot::get_plan_target_joint_q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the planning target joint positions in joint space. </p>
<p>This "target joint position" is the long-term joint position goal of the robot arm. It is set by the user by calling position controlling functions with <code>use_planning</code> set to <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt;: target joint positions in radians. </dd></dl>

</div>
</div>
<a id="a896798269a138c327588d1e3208e04f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896798269a138c327588d1e3208e04f8">&#9670;&nbsp;</a></span>get_plan_target_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; double &gt; &gt; arm::Robot::get_plan_target_pose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the planning target end pose in Cartesian space. </p>
<p>This "planning target pose" is the long-term end pose goal for planning of the robot arm. It is set by the user by calling position controlling functions with <code>use_planning</code> set to <code>true</code>.</p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;vector&lt;double&gt;&gt;: planning target end pose consisting of translation in meters and quaternion rotation in <code>(( x, y, z ), ( rx, ry, rz, rw ))</code> format. </dd></dl>

</div>
</div>
<a id="a49003282ec9bed89926d39eaff9bf821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49003282ec9bed89926d39eaff9bf821">&#9670;&nbsp;</a></span>get_sn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string arm::Robot::get_sn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the SN code of the robot arm. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string: the serial number of the robot arm. </dd></dl>

</div>
</div>
<a id="a13044f0b9a63b331d552fca0bc177897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13044f0b9a63b331d552fca0bc177897">&#9670;&nbsp;</a></span>get_target_joint_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; arm::Robot::get_target_joint_q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target joint positions in joint space. </p>
<p>This "target joint position" is the short-term joint position goal of the robot arm. It can be either set by the user by calling position controlling functions with <code>use_planning</code> set to <code>false</code>, or by the robot itself when planning is enabled.</p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt;: target joint positions in radians. </dd></dl>

</div>
</div>
<a id="a714a388fddfe380385f0d89530ea9f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714a388fddfe380385f0d89530ea9f1d">&#9670;&nbsp;</a></span>get_target_joint_v()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; arm::Robot::get_target_joint_v </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target joint velocities in joint space. </p>
<p>This "target joint velocity" is the velocity goal of the robot arm. It is set by the user by calling velocity controlling functions.</p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt;: target joint velocities in radians per second. </dd></dl>

</div>
</div>
<a id="a6ec687a3a73cd5bafe1564d01adaf93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec687a3a73cd5bafe1564d01adaf93a">&#9670;&nbsp;</a></span>get_target_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; double &gt; &gt; arm::Robot::get_target_pose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target end pose in Cartesian space. </p>
<p>This "target pose" is the short-term end pose goal of the robot arm. It can be either set by the user by calling position controlling functions with <code>use_planning</code> set to <code>false</code>, or by the robot itself when planning is enabled.</p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;vector&lt;double&gt;&gt;: target end pose consisting of translation and quaternion rotation in <code>(( x, y, z ), ( rx, ry, rz, rw ))</code> format. </dd></dl>

</div>
</div>
<a id="aae4791544f6e44ab3a5778153d77109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4791544f6e44ab3a5778153d77109d">&#9670;&nbsp;</a></span>get_target_rotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; arm::Robot::get_target_rotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the rotation part of the target end pose. </p>
<p>The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector. The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt;: target rotation in quaternion format <code>( rx, ry, rz, rw )</code>. </dd></dl>

</div>
</div>
<a id="a4f45efa7f178811dda4f45b3e491514b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f45efa7f178811dda4f45b3e491514b">&#9670;&nbsp;</a></span>get_target_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; arm::Robot::get_target_translation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the translation part of the target end pose. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;double&gt;: target translation in meters. </dd></dl>

</div>
</div>
<a id="a3e0fa253d03b7eef6d236dba1c79ed33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0fa253d03b7eef6d236dba1c79ed33">&#9670;&nbsp;</a></span>reached_target_joint_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arm::Robot::reached_target_joint_q </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.01</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the robot has reached the target joint positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>the threshold for determining if the robot has reached the target joint positions. The default value is 0.01 radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the robot has reached the target joint positions, false otherwise. </dd></dl>

</div>
</div>
<a id="af72d4095fde785566b58d56e0079e88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72d4095fde785566b58d56e0079e88c">&#9670;&nbsp;</a></span>reached_target_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arm::Robot::reached_target_pose </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.01</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the robot has reached the target pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>the threshold for determining if the robot has reached the target pose. The default value is 0.01 meters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the robot has reached the target pose, false otherwise. </dd></dl>

</div>
</div>
<a id="a80009633b8ad383d1b8f45de68d49548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80009633b8ad383d1b8f45de68d49548">&#9670;&nbsp;</a></span>record_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::record_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the recorded trajectory from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>the path to the file where the recorded trajectory is saved. </td></tr>
  </table>
  </dd>
</dl>
<p>Check the existense of file</p>

</div>
</div>
<a id="a1d5083a372e9e789e39c8c30afe86372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5083a372e9e789e39c8c30afe86372">&#9670;&nbsp;</a></span>record_replay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::record_replay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replay the recorded / loaded trajectory of the robot arm. </p>
<p>Bring robot to initial position</p>
<p>Replay</p>

</div>
</div>
<a id="a54c933ad91fc4dcc39c36f2109108d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c933ad91fc4dcc39c36f2109108d6a">&#9670;&nbsp;</a></span>record_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::record_save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the recorded trajectory to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>the path to the file where the recorded trajectory will be saved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4cd197b5f1d540bc12c23c8a6bc62ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cd197b5f1d540bc12c23c8a6bc62ff">&#9670;&nbsp;</a></span>record_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::record_start </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>record_type</em> = <code>&quot;q&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start recording the trajectory of the robot arm. </p>
<p>The robot will record the joint positions, velocities, and torques, as well as the end position, at each time step. The recorded data can be saved to a file and replayed later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">record_type</td><td>DEPRECATED. This parameter is for backward compatibility and will be removed in the future. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad65f7274a04350c64d7d11c1f30e3a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65f7274a04350c64d7d11c1f30e3a1b">&#9670;&nbsp;</a></span>set_target_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::set_target_end </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>end_pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the target end position of the robot arm. The end position is a normalized value between 0 and 1, where 0 denotes that the end effector is closed and 1 denotes that the end effector is open. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end</td><td>the normalized target end position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa00fd5be719eeff43c37e6a726daa574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00fd5be719eeff43c37e6a726daa574">&#9670;&nbsp;</a></span>set_target_joint_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::set_target_joint_q </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>DEFAULT_TIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target joint positions of the robot arm in joint space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_joint_q</td><td>the target joint positions in radians. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">time</td><td>the time scale to reach the target pose. If planning is disabled, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dcd76724848d66e7a1df6564a1569bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcd76724848d66e7a1df6564a1569bc">&#9670;&nbsp;</a></span>set_target_joint_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::set_target_joint_t </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Torque control method. Set the target joint torques of the robot arm in joint space. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>This function is not implemented yet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_joint_t</td><td>the target joint torques in Newton meters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6cc3427b836f7cf2a72da21b2d9d02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cc3427b836f7cf2a72da21b2d9d02e">&#9670;&nbsp;</a></span>set_target_joint_v()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::set_target_joint_v </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_joint_v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Velocity control method. Set the target joint velocities of the robot arm in joint space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_joint_v</td><td>the target joint velocities in radians per second. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae05533609f6ebe1279fc1734ad383ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05533609f6ebe1279fc1734ad383ac5">&#9670;&nbsp;</a></span>set_target_pose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::set_target_pose </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>DEFAULT_TIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target end pose of the robot arm in Cartesian space. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_translation</td><td>the target translation in meters. </td></tr>
    <tr><td class="paramname">target_rotation</td><td>the target rotation in quaternion format <code>( rx, ry, rz, rw )</code>. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">time</td><td>the time scale to reach the target pose. If planning is disabled, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd0bec26dabf7c103cc7e6c0ff19684d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0bec26dabf7c103cc7e6c0ff19684d">&#9670;&nbsp;</a></span>set_target_pose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::set_target_pose </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>target_pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>DEFAULT_TIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target end pose of the robot arm in Cartesian space. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_pose</td><td>the target pose in Cartesian space. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">time</td><td>the time scale to reach the target pose. If planning is disabled, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a1045902e6317812faeee539584a8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1045902e6317812faeee539584a8cc">&#9670;&nbsp;</a></span>set_target_rotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::set_target_rotation </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>DEFAULT_TIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target rotation of the robot arm in Cartesian space. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up. The rotation is represented by a quaternion relative to the <code>(1, 0, 0)</code> unit vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_rotation</td><td>the target rotation in quaternion format <code>( rx, ry, rz, rw )</code>. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">time</td><td>the time scale to reach the target pose. If planning is disabled, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4d85c1a88bf5d691bee5de3199c931b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d85c1a88bf5d691bee5de3199c931b">&#9670;&nbsp;</a></span>set_target_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::set_target_translation </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_planning</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code>DEFAULT_TIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Position control method. Set the target translation of the robot arm in Cartesian space. </p>
<p>The reference frame is the base frame, where the origin is located at the base, x axis is pointing to the front, y axis is pointing to the left, and z axis is pointing up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_translation</td><td>the target translation in meters. </td></tr>
    <tr><td class="paramname">use_planning</td><td>whether or not to use planning. If <code>true</code>, the robot will plan the trajectory to the target pose with cubic interpolation. If <code>false</code>, the robot will move directly to the target pose. </td></tr>
    <tr><td class="paramname">time</td><td>the time scale to reach the target pose. If planning is disabled, this parameter will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64cbda1eeb5696f54e236342b5dd382c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cbda1eeb5696f54e236342b5dd382c">&#9670;&nbsp;</a></span>set_target_vel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::set_target_vel </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>target_vel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Velocity control method. Set the target end velocities of the robot arm in Cartesian space. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>This function is not implemented yet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_vel</td><td>the target end velocities in meters per second. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addd37390481bde902f265a0b6a726258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd37390481bde902f265a0b6a726258">&#9670;&nbsp;</a></span>update_motor_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void arm::Robot::update_motor_ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>send</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING It is important to use the same "state" as the one used to decide whether to send control mode change command (which means get_state should be called only once), otherwise the DM motor would be in fast-rotating state causing unintended and possibly severe damage!!!!</p>
<p>This is caused by a bug in the firmware of DM motor: if MitModeCmd is sent to DM motor before calling set_motor_control_mode(1) (entering torque controlmode), the DM motor will be in fast-rotating state. WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING</p>
<p>NOTE: the following sleep is necessary to avoid sending too many commands to the motor driver, which will cause the motor driver to ignore some commands. 1000 microseconds is a carefully chosen and tested value.</p>
<p>NOTE: the following sleep is necessary to avoid sending too many commands to the motor driver, which will cause the motor driver to ignore some commands. 3000 microseconds is a carefully chosen and tested value.</p>

</div>
</div>
<a id="a17762deeee58a73ee055586ec1dcff83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17762deeee58a73ee055586ec1dcff83">&#9670;&nbsp;</a></span>valid_joint_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arm::Robot::valid_joint_q </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint_q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the given target joint positions are valid for AIRBOT Play. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">joint_q</td><td>the target joint positions in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the robot arm is in the target joint positions, false otherwise. </dd></dl>

</div>
</div>
<a id="a2e029afff87e1533bd2e21eba6a95d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e029afff87e1533bd2e21eba6a95d98">&#9670;&nbsp;</a></span>valid_target_pose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool arm::Robot::valid_target_pose </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>target_pose</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the given target pose is valid for AIRBOT Play. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_pose</td><td>the target pose in Cartesian space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the pose is valid, false otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/airbot/command/<a class="el" href="command__base_8hpp_source.html">command_base.hpp</a></li>
<li>src/airbot/command/command_base.cpp</li>
<li>src/airbot/command/end_control.cpp</li>
<li>src/airbot/command/joint_control.cpp</li>
<li>src/airbot/command/replay.cpp</li>
<li>src/airbot/command/update.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
